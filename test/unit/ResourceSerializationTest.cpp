/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <array>
#include <fstream>
#include <gtest/gtest.h>

#include "ApkResources.h"
#include "Debug.h"
#include "RedexMappedFile.h"
#include "RedexResources.h"
#include "RedexTestUtils.h"
#include "SanitizersConfig.h"
#include "Util.h"
#include "androidfw/ResourceTypes.h"
#include "utils/Serialize.h"
#include "utils/Visitor.h"

namespace {
// Chunk of just the ResStringPool, as generated by aapt2 (has 2 UTF8 strings)
const std::array<uint8_t, 84> example_data_8{
    {0x01, 0x00, 0x1C, 0x00, 0x54, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
     0x0C, 0x0C, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x77, 0x6F, 0x72,
     0x6C, 0x64, 0x00, 0x1C, 0x1C, 0x72, 0x65, 0x73, 0x2F, 0x6C, 0x61, 0x79,
     0x6F, 0x75, 0x74, 0x2F, 0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x5F, 0x6C,
     0x61, 0x79, 0x6F, 0x75, 0x74, 0x2E, 0x78, 0x6D, 0x6C, 0x00, 0x00, 0x00}};

// Another aapt2 generated ResStringPool, encoded as UTF-16.
const std::array<uint8_t, 116> example_data_16{
    {0x01, 0x00, 0x1C, 0x00, 0x74, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00,
     0x1C, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
     0x05, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6C, 0x00, 0x6F, 0x00, 0x72, 0x00,
     0x00, 0x00, 0x05, 0x00, 0x64, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x65, 0x00,
     0x6E, 0x00, 0x00, 0x00, 0x02, 0x00, 0x69, 0x00, 0x64, 0x00, 0x00, 0x00,
     0x06, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x79, 0x00, 0x6F, 0x00, 0x75, 0x00,
     0x74, 0x00, 0x00, 0x00, 0x06, 0x00, 0x73, 0x00, 0x74, 0x00, 0x72, 0x00,
     0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x00, 0x00}};

std::string make_big_string(size_t len) {
  always_assert(len > 4);
  std::string result = "aa" + std::string(len - 4, 'x') + "zz";
  return result;
}

UNUSED void assert_u16_string(const std::u16string& actual_str,
                              const std::string& expected) {
  std::u16string expected_str(expected.begin(), expected.end());
  ASSERT_EQ(actual_str, expected_str);
}

void assert_serialized_data(const void* original,
                            size_t length,
                            android::Vector<char>& serialized) {
  ASSERT_EQ(length, serialized.size());
  for (size_t i = 0; i < length; i++) {
    auto actual = *((const char*)original + i);
    ASSERT_EQ(actual, serialized[i]) << "Mismatch at offset " << i;
  }
}

void copy_file(const std::string& from, const std::string& to) {
  std::ifstream src_stream(from, std::ios::binary);
  std::ofstream dest_stream(to, std::ios::binary);
  dest_stream << src_stream.rdbuf();
}

bool are_files_equal(const std::string& p1, const std::string& p2) {
  std::ifstream f1(p1, std::ifstream::binary | std::ifstream::ate);
  std::ifstream f2(p2, std::ifstream::binary | std::ifstream::ate);
  always_assert_log(!f1.fail(), "Failed to read path %s", p1.c_str());
  always_assert_log(!f2.fail(), "Failed to read path %s", p2.c_str());
  if (f1.tellg() != f2.tellg()) {
    std::cerr << "File length mismatch. " << f1.tellg() << " != " << f2.tellg()
              << std::endl;
    return false;
  }
  f1.seekg(0, std::ifstream::beg);
  f2.seekg(0, std::ifstream::beg);
  return std::equal(std::istreambuf_iterator<char>(f1.rdbuf()),
                    std::istreambuf_iterator<char>(),
                    std::istreambuf_iterator<char>(f2.rdbuf()));
}

void write_to_file(const std::string& output_path,
                   android::Vector<char>& data) {
  std::ofstream fout(output_path,
                     std::ios::out | std::ios::binary | std::ios::trunc);
  always_assert_log(fout.is_open(), "Could not open path %s for writing",
                    output_path.c_str());
  fout.write(data.array(), data.size());
  fout.close();
}
} // namespace

TEST(ResStringPool, ReplaceStringsInXmlLayout) {
  // Given layout file should have a series of View subclasses in the XML, which
  // we will rename. Parse the resulting binary data, and make sure all tags are
  // right.
  auto f = RedexMappedFile::open(std::getenv("test_layout_path"));

  std::map<std::string, std::string> shortened_names;
  shortened_names.emplace("com.example.test.CustomViewGroup", "Z.a");
  shortened_names.emplace("com.example.test.CustomTextView", "Z.b");
  shortened_names.emplace("com.example.test.CustomButton", "Z.c");
  shortened_names.emplace("com.example.test.NotFound", "Z.d");

  android::Vector<char> serialized;
  size_t num_renamed = 0;
  ApkResources resources("");
  resources.replace_in_xml_string_pool(
      f.const_data(), f.size(), shortened_names, &serialized, &num_renamed);

  EXPECT_EQ(num_renamed, 3);
  android::ResXMLTree parser;
  parser.setTo(&serialized[0], serialized.size());
  EXPECT_EQ(android::NO_ERROR, parser.getError())
      << "Error parsing layout after rename";

  std::vector<std::string> expected_xml_tags;
  expected_xml_tags.push_back("Z.a");
  expected_xml_tags.push_back("TextView");
  expected_xml_tags.push_back("Z.b");
  expected_xml_tags.push_back("Z.c");
  expected_xml_tags.push_back("Button");

  size_t tag_count = 0;
  android::ResXMLParser::event_code_t type;
  do {
    type = parser.next();
    if (type == android::ResXMLParser::START_TAG) {
      EXPECT_LT(tag_count, 5);
      size_t len;
      android::String8 tag(parser.getElementName(&len));
      auto actual_chars = tag.string();
      auto expected_chars = expected_xml_tags[tag_count].c_str();
      EXPECT_STREQ(actual_chars, expected_chars);
      tag_count++;
    }
  } while (type != android::ResXMLParser::BAD_DOCUMENT &&
           type != android::ResXMLParser::END_DOCUMENT);
  EXPECT_EQ(tag_count, 5);
}

TEST(ResTable, AppendNewType) {
  auto src_file_path = std::getenv("test_arsc_path");
  auto tmp_dir = redex::make_tmp_dir("ResTable_AppendNewType%%%%%%%%");
  auto dest_file_path = tmp_dir.path + "/resources.arsc";
  copy_file(src_file_path, dest_file_path);

  auto src = RedexMappedFile::open(src_file_path);
  // TODO: replace use of android::ResTable throughout this file.
  android::ResTable table;
  ASSERT_EQ(table.add(src.const_data(), src.size()), 0);
  // Read the number of original types.
  std::vector<std::string> original_type_names;
  {
    apk::TableSnapshot table_snapshot(src, src.size());
    table_snapshot.get_type_names(APPLICATION_PACKAGE, &original_type_names);
  }

  // Set up existing entry data to copy into a different type
  const uint8_t dest_type = 3;
  std::vector<uint32_t> source_ids;
  source_ids.push_back(0x7f010000);
  size_t num_ids = source_ids.size();
  android::Vector<android::Res_value> values;
  for (size_t i = 0; i < num_ids; i++) {
    android::Res_value val;
    table.getResource(source_ids[i], &val);
    values.push_back(val);
  }

  // Create a default looking ResTable_config
  android::ResTable_config default_config;
  memset(&default_config, 0, sizeof(android::ResTable_config));
  default_config.size = sizeof(android::ResTable_config);

  // Write a new .arsc file
  {
    ResourcesArscFile arsc_file(dest_file_path);
    std::vector<android::ResTable_config*> config_ptrs;
    config_ptrs.emplace_back(&default_config);
    arsc_file.define_type(0x7f, 3, "foo", config_ptrs, source_ids);
    arsc_file.serialize();
  }

  auto dest = RedexMappedFile::open(dest_file_path);
  android::ResTable round_trip;
  ASSERT_EQ(round_trip.add(dest.const_data(), dest.size()), 0);
  apk::TableSnapshot round_trip_snapshot(dest, dest.size());
  // Make sure entries exist in 0x7f03xxxx range
  for (size_t i = 0; i < num_ids; i++) {
    auto old_id = source_ids[i];
    auto new_id = 0x7f000000 | (dest_type << 16) | (old_id & 0xFFFF);
    android::Res_value expected = values[i];
    android::Res_value actual;
    round_trip.getResource(new_id, &actual);
    ASSERT_EQ(expected.dataType, actual.dataType);
    ASSERT_EQ(expected.data, actual.data);
  }

  // Sanity check values in their original location
  {
    android::Res_value out_value;
    round_trip.getResource(0x7f010000, &out_value);
    float val = arsc::complex_value(out_value.data);
    uint32_t unit = arsc::complex_unit(out_value.data, false);
    ASSERT_EQ((int)val, 10);
    ASSERT_EQ(unit, android::Res_value::COMPLEX_UNIT_DIP);
  }
  {
    android::Res_value out_value;
    round_trip.getResource(0x7f010001, &out_value);
    float val = arsc::complex_value(out_value.data);
    uint32_t unit = arsc::complex_unit(out_value.data, false);
    ASSERT_EQ((int)val, 20);
    ASSERT_EQ(unit, android::Res_value::COMPLEX_UNIT_DIP);
  }

  std::vector<std::string> type_names;
  round_trip_snapshot.get_type_names(APPLICATION_PACKAGE, &type_names);
  ASSERT_EQ(type_names.size(), original_type_names.size() + 1);
}

TEST(ResStringPoolBuilder, TestPoolRebuild8) {
  android::ResStringPool pool(&example_data_8, example_data_8.size(), false);
  auto flags =
      (pool.isUTF8() ? android::ResStringPool_header::UTF8_FLAG : 0) |
      (pool.isSorted() ? android::ResStringPool_header::SORTED_FLAG : 0);
  auto pool_size = pool.size();

  arsc::ResStringPoolBuilder builder(flags);
  for (size_t i = 0; i < pool_size; i++) {
    size_t out_len;
    auto s = pool.string8At(i, &out_len);
    builder.add_string(s, out_len);
  }
  android::Vector<char> serialized;
  builder.serialize(&serialized);
  assert_serialized_data(&example_data_8, example_data_8.size(), serialized);
}

TEST(ResStringPoolBuilder, TestPoolRebuild16) {
  android::ResStringPool pool(&example_data_16, example_data_16.size(), false);
  auto flags =
      (pool.isUTF8() ? android::ResStringPool_header::UTF8_FLAG : 0) |
      (pool.isSorted() ? android::ResStringPool_header::SORTED_FLAG : 0);
  auto pool_size = pool.size();

  arsc::ResStringPoolBuilder builder(flags);
  for (size_t i = 0; i < pool_size; i++) {
    size_t out_len;
    auto s = pool.stringAt(i, &out_len);
    builder.add_string(s, out_len);
  }
  android::Vector<char> serialized;
  builder.serialize(&serialized);
  assert_serialized_data(&example_data_16, example_data_16.size(), serialized);
}

TEST(ResStringPoolBuilder, TestPoolRebuildStyle8) {
  const std::array<uint8_t, 232> data{
      {0x01, 0x00, 0x1c, 0x00, 0xe8, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
       0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
       0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
       0x41, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
       0x59, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x1c, 0x00, 0x00, 0x00, 0x11, 0x11, 0x41, 0x6e, 0x20, 0x75, 0x6e, 0x75,
       0x73, 0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x00,
       0x2a, 0x2a, 0x49, 0x20, 0x6c, 0x69, 0x6b, 0x65, 0x20, 0x61, 0x20, 0x66,
       0x69, 0x6e, 0x65, 0x20, 0x67, 0x6c, 0x61, 0x73, 0x73, 0x20, 0x6f, 0x66,
       0x20, 0x48, 0x32, 0x4f, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20,
       0x6d, 0x6f, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x21, 0x00, 0x0c, 0x0c, 0x48,
       0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x2e, 0x00,
       0x01, 0x01, 0x62, 0x00, 0x02, 0x02, 0x65, 0x6d, 0x00, 0x03, 0x03, 0x73,
       0x75, 0x62, 0x00, 0x03, 0x03, 0x73, 0x75, 0x70, 0x00, 0x00, 0x00, 0x00,
       0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
       0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
       0xff, 0xff, 0xff, 0xff, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
       0x0c, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
       0x18, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
       0xff, 0xff, 0xff, 0xff}};
  android::ResStringPool pool(&data, data.size(), false);
  auto flags =
      (pool.isUTF8() ? android::ResStringPool_header::UTF8_FLAG : 0) |
      (pool.isSorted() ? android::ResStringPool_header::SORTED_FLAG : 0);
  auto pool_size = pool.size();
  auto style_count = pool.styleCount();
  arsc::ResStringPoolBuilder builder(flags);
  for (size_t i = 0; i < pool_size; i++) {
    size_t out_len;
    auto s = pool.string8At(i, &out_len);
    if (i < style_count) {
      arsc::SpanVector vec;
      auto span = (android::ResStringPool_span*)pool.styleAt(i);
      arsc::collect_spans(span, &vec);
      builder.add_style(s, out_len, vec);
    } else {
      builder.add_string(s, out_len);
    }
  }
  EXPECT_EQ(pool.size(), builder.string_count());
  android::Vector<char> serialized;
  builder.serialize(&serialized);
  assert_serialized_data(&data, data.size(), serialized);
}

TEST(ResStringPoolBuilder, TestAllTheOptions) {
  std::string hello_world("Hello world!");
  android::String16 hello_world16("Hello world!");
  android::String8 foo("foo");
  android::String16 bar("bar");
  auto big_std_string = make_big_string(1000);
  std::string em("em");

  android::ResStringPool_span span{
      .name = {.index = 4}, .firstChar = 6, .lastChar = 10};
  std::vector<android::ResStringPool_span*> spans = {&span};

  auto do_validation = [&](void* data, size_t size) {
    android::ResStringPool pool;
    EXPECT_EQ(pool.setTo(data, size), 0);
    EXPECT_EQ(pool.styleCount(), 1);
    EXPECT_EQ(pool.size(), 5);
    EXPECT_STREQ(apk::get_string_from_pool(pool, 0).c_str(), "Hello world!");
    EXPECT_STREQ(apk::get_string_from_pool(pool, 1).c_str(), "foo");
    EXPECT_STREQ(apk::get_string_from_pool(pool, 2).c_str(), "bar");
    EXPECT_STREQ(apk::get_string_from_pool(pool, 3).c_str(),
                 big_std_string.c_str());
    EXPECT_STREQ(apk::get_string_from_pool(pool, 4).c_str(), "em");
  };

  {
    arsc::ResStringPoolBuilder builder(0);
    builder.add_style(hello_world, spans);
    builder.add_string(foo.string(), foo.size());
    builder.add_string(bar.string(), bar.size());
    builder.add_string(big_std_string);
    builder.add_string(em);

    android::Vector<char> out;
    builder.serialize(&out);
    do_validation((void*)out.array(), out.size());
  }
  {
    arsc::ResStringPoolBuilder builder(
        android::ResStringPool_header::UTF8_FLAG);
    builder.add_style(hello_world16.string(), hello_world16.size(), spans);
    builder.add_string(foo.string(), foo.size());
    builder.add_string(bar.string(), bar.size());
    builder.add_string(big_std_string);
    builder.add_string(em);

    android::Vector<char> out;
    builder.serialize(&out);
    do_validation((void*)out.array(), out.size());
  }
}

TEST(ResTableParse, TestUnknownPackageChunks) {
  // A table with one package, which has a fake chunk that is made up. The chunk
  // that is not known/recognized should just be copied as-is to the output.
  auto tmp_dir = redex::make_tmp_dir("ResTableParse%%%%%%%%");
  auto res_path = tmp_dir.path + "/resources.arsc";
  copy_file(std::getenv("resources_unknown_chunk"), res_path);
  ResourcesArscFile res_table(res_path);
  res_table.remove_unreferenced_strings();
  EXPECT_TRUE(
      are_files_equal(std::getenv("resources_unknown_chunk"), res_path));
}

TEST(Configs, TestConfigEquivalence) {
  android::ResTable_config default_config{};
  default_config.size = sizeof(android::ResTable_config);
  EXPECT_TRUE(arsc::are_configs_equivalent(&default_config, &default_config));
  android::ResTable_config land_config{};
  land_config.size = sizeof(android::ResTable_config);
  land_config.orientation = android::ResTable_config::ORIENTATION_LAND;
  EXPECT_FALSE(arsc::are_configs_equivalent(&default_config, &land_config));
  // Configs of different sizes (simulate some of our snapshots of older files)
  {
    struct SmallConfig {
      uint32_t a;
      uint32_t b;
      uint32_t c;
      uint32_t d;
    };
    SmallConfig small_config{};
    small_config.a = sizeof(SmallConfig);
    EXPECT_TRUE(arsc::are_configs_equivalent(
        &default_config, (android::ResTable_config*)&small_config));
  }
  {
    PACKED(struct BiggerConfig {
      android::ResTable_config config{};
      uint32_t a;
      uint32_t b;
      uint32_t c;
      uint32_t d;
    });
    BiggerConfig big_config{};
    big_config.config = default_config;
    big_config.config.size = sizeof(BiggerConfig);
    // Can't determine default values of newer versions we don't know about.
    EXPECT_FALSE(arsc::are_configs_equivalent(
        &default_config, (android::ResTable_config*)&big_config));
  }
}

TEST(ResTable, TestBuilderRoundTrip) {
  auto tmp_dir = redex::make_tmp_dir("ResTable%%%%%%%%");
  auto res_path = tmp_dir.path + "/resources.arsc";
  copy_file(std::getenv("test_arsc_path"), res_path);
  ResourcesArscFile res_table(res_path);
  res_table.serialize();
  EXPECT_TRUE(are_files_equal(std::getenv("test_arsc_path"), res_path));
}

namespace {
PACKED(struct EntryAndValue {
  android::ResTable_entry entry{};
  android::Res_value value{};
  EntryAndValue(uint32_t key_string_idx, uint8_t data_type, uint32_t data) {
    entry.size = sizeof(android::ResTable_entry);
    entry.key.index = key_string_idx;
    value.size = sizeof(android::Res_value);
    value.dataType = data_type;
    value.data = data;
  }
});

// For testing simplicity, a map that has two items in it.
PACKED(struct MapEntryAndValues {
  android::ResTable_map_entry entry{};
  android::ResTable_map item0{};
  android::ResTable_map item1{};
  MapEntryAndValues(uint32_t key_string_idx, uint32_t parent_ident) {
    entry.size = sizeof(android::ResTable_map_entry);
    entry.count = 2;
    entry.flags = android::ResTable_entry::FLAG_COMPLEX;
    entry.key.index = key_string_idx;
    entry.parent.ident = parent_ident;
    item0.value.size = sizeof(android::Res_value);
    item1.value.size = sizeof(android::Res_value);
  }
});
} // namespace

TEST(ResTable, ComputeSizes) {
  EntryAndValue simple(0, android::Res_value::TYPE_DIMENSION, 1000);
  EXPECT_EQ(arsc::compute_entry_value_length(&simple.entry),
            sizeof(EntryAndValue));
  MapEntryAndValues complex(1, 0);
  EXPECT_EQ(arsc::compute_entry_value_length(&complex.entry),
            sizeof(MapEntryAndValues));
}

namespace {
// Data for a simple arsc file that many tests can get written against.
EntryAndValue e0(0, android::Res_value::TYPE_DIMENSION, 1000);
EntryAndValue e0_land(0, android::Res_value::TYPE_DIMENSION, 1001);
EntryAndValue e1(1, android::Res_value::TYPE_DIMENSION, 2000);
EntryAndValue e2(2, android::Res_value::TYPE_REFERENCE, 0x7f010001);
EntryAndValue id_0(0, android::Res_value::TYPE_INT_BOOLEAN, 0);
EntryAndValue id_1(1, android::Res_value::TYPE_INT_BOOLEAN, 0);
EntryAndValue id_2(2, android::Res_value::TYPE_INT_BOOLEAN, 0);
MapEntryAndValues style(3, 0);

// The package that all tests to follow will be in
android::ResTable_package package_header{.id = 0x7f,
                                         .name = {'f', 'o', 'o', '\0'}};
// Create a default ResTable_config
android::ResTable_config default_config = {
    .size = sizeof(android::ResTable_config)};
// Create a landscape config
android::ResTable_config land_config = {
    .size = sizeof(android::ResTable_config),
    .orientation = android::ResTable_config::ORIENTATION_LAND};
// And a xxhdpi config
android::ResTable_config xxhdpi_config = {
    .size = sizeof(android::ResTable_config),
    .density = android::ResTable_config::DENSITY_XXHIGH};

void build_arsc_file_and_validate(
    const std::function<void(const std::string& temp_dir,
                             const std::string& arsc_path)>& callback) {
  auto pool_flags = android::ResStringPool_header::UTF8_FLAG;
  auto global_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);

  auto key_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  constexpr uint16_t ENTRY_COUNT = 4;
  const char* entry_names[ENTRY_COUNT] = {"first", "second", "third", "fourth"};
  for (uint16_t i = 0; i < ENTRY_COUNT; i++) {
    key_strings_builder->add_string(entry_names[i], strlen(entry_names[i]));
  }

  auto type_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  constexpr uint8_t TYPE_COUNT = 2;
  const char* type_names[2] = {"dimen", "style"};
  for (uint16_t i = 0; i < TYPE_COUNT; i++) {
    type_strings_builder->add_string(type_names[i], strlen(type_names[i]));
  }

  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(key_strings_builder);
  package_builder->set_type_strings(type_strings_builder);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(global_strings_builder);
  table_builder->add_package(package_builder);

  // dimen
  std::vector<android::ResTable_config*> dimen_configs = {&default_config,
                                                          &land_config};
  // First res ID has entries in two different configs (this flag denotes that).
  // Subsequent two entries only have default config entries (hence zero).
  std::vector<uint32_t> dimen_flags = {
      android::ResTable_config::CONFIG_ORIENTATION, 0, 0};
  auto dimen_type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 1, dimen_configs, dimen_flags);
  package_builder->add_type(dimen_type_definer);

  dimen_type_definer->add(&default_config,
                          {(uint8_t*)&e0, sizeof(EntryAndValue)});
  dimen_type_definer->add(&land_config,
                          {(uint8_t*)&e0_land, sizeof(EntryAndValue)});
  dimen_type_definer->add(&default_config,
                          {(uint8_t*)&e1, sizeof(EntryAndValue)});
  dimen_type_definer->add_empty(&land_config);
  dimen_type_definer->add(&default_config,
                          {(uint8_t*)&e2, sizeof(EntryAndValue)});
  dimen_type_definer->add_empty(&land_config);

  // style
  std::vector<android::ResTable_config*> style_configs = {&xxhdpi_config};
  std::vector<uint32_t> style_flags = {
      android::ResTable_config::CONFIG_DENSITY};
  auto style_type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 2, style_configs, style_flags);
  package_builder->add_type(style_type_definer);

  style.item0.name.ident = 0x01010098; // android:textColor
  style.item0.value.dataType = android::Res_value::TYPE_INT_COLOR_RGB8;
  style.item0.value.data = 0xFF0000FF;

  style.item1.name.ident = 0x010100d4; // android:background
  style.item1.value.dataType = android::Res_value::TYPE_INT_COLOR_RGB8;
  style.item1.value.data = 0xFF00FF00;

  style_type_definer->add(&xxhdpi_config,
                          {(uint8_t*)&style, sizeof(MapEntryAndValues)});

  // Write to a file, give the callback the temp dir and file to validate
  // against.
  android::Vector<char> out;
  table_builder->serialize(&out);

  auto tmp_dir = redex::make_tmp_dir("ResTable_BuildNewTable%%%%%%%%");
  auto dest_file_path = tmp_dir.path + "/resources.arsc";
  std::cerr << "Writing new table to " << dest_file_path.c_str() << std::endl;
  write_to_file(dest_file_path, out);
  callback(tmp_dir.path, dest_file_path);
}

// Look up a string like "com.facebook.foo:dimen/whatever" and return the ID.
uint32_t get_identifier(const android::ResTable& table,
                        const char* fully_qualified_entry) {
  android::String16 e(fully_qualified_entry);
  return table.identifierForName(e.string(), e.size());
}

// Look up resource IDs by the package, type and entry names, even though we
// could just compute them ourselves (battle test the type, key strings being
// accurate).
ssize_t get_value_by_name(const android::ResTable& table,
                          const char* fully_qualified_entry,
                          android::Res_value* out) {
  return table.getResource(get_identifier(table, fully_qualified_entry), out);
}

void delete_resources(const std::string& arsc_file_path,
                      const std::vector<uint32_t>& ids_to_delete) {
  ResourcesArscFile arsc_file(arsc_file_path);
  // Should delete all of the style entries and omit that typeSpec and
  // type entirely during serialization.
  for (const auto& id : ids_to_delete) {
    arsc_file.delete_resource(id);
  }
  arsc_file.serialize();
  // We actually have to reload the table, since all modifications are
  // meant to be written directly to disk afterwards.
  ResourcesArscFile reloaded_file(arsc_file_path);
  reloaded_file.remove_unreferenced_strings();
}

UNUSED int32_t load_global_strings(const RedexMappedFile& arsc_file,
                                   android::ResStringPool* pool) {
  apk::TableParser parser;
  parser.visit((void*)arsc_file.const_data(), arsc_file.size());
  auto pool_header = parser.m_global_pool_header;
  return pool->setTo(pool_header, pool_header->header.size);
}

int32_t load_key_strings(const RedexMappedFile& arsc_file,
                         android::ResStringPool* pool) {
  apk::TableParser parser;
  parser.visit((void*)arsc_file.const_data(), arsc_file.size());
  // Only 1 package in our test arsc file.
  auto pool_header = parser.m_package_key_string_headers.begin()->second;
  return pool->setTo(pool_header, pool_header->header.size);
}

int32_t load_type_strings(const RedexMappedFile& arsc_file,
                          android::ResStringPool* pool) {
  apk::TableParser parser;
  parser.visit((void*)arsc_file.const_data(), arsc_file.size());
  // Only 1 package in our test arsc file.
  auto pool_header = parser.m_package_type_string_headers.begin()->second;
  return pool->setTo(pool_header, pool_header->header.size);
}

std::vector<arsc::TypeInfo> load_types(const RedexMappedFile& arsc_file) {
  apk::TableParser parser;
  parser.visit((void*)arsc_file.const_data(), arsc_file.size());
  return parser.m_package_types.begin()->second;
}

// Assert values in the table match the expected "EntryAndValue"
#define ASSERT_ENTRY_VALUES(table, entry_str, expected)                     \
  ({                                                                        \
    android::Res_value __actual_value;                                      \
    EXPECT_EQ(get_value_by_name((table), (entry_str), &__actual_value), 0); \
    EXPECT_EQ((expected).value.size, __actual_value.size);                  \
    EXPECT_EQ((expected).value.dataType, __actual_value.dataType);          \
    EXPECT_EQ((expected).value.data, __actual_value.data);                  \
  })
// Assert values in the table match the two items expecrted in the
// "MapEntryAndValues"
#define ASSERT_MAP_ENTRY_VALUES(table, entry_str, expected)                  \
  ({                                                                         \
    const android::ResTable::bag_entry* __bag_entry;                         \
    EXPECT_EQ(                                                               \
        (table).lockBag(get_identifier((table), (entry_str)), &__bag_entry), \
        2);                                                                  \
    EXPECT_EQ(__bag_entry->map.name.ident, (expected).item0.name.ident);     \
    EXPECT_EQ(__bag_entry->map.value.dataType,                               \
              (expected).item0.value.dataType);                              \
    EXPECT_EQ(__bag_entry->map.value.data, (expected).item0.value.data);     \
    __bag_entry++;                                                           \
    EXPECT_EQ(__bag_entry->map.name.ident, (expected).item1.name.ident);     \
    EXPECT_EQ(__bag_entry->map.value.dataType,                               \
              (expected).item1.value.dataType);                              \
    EXPECT_EQ(__bag_entry->map.value.data, (expected).item1.value.data);     \
    __bag_entry--;                                                           \
    (table).unlockBag(__bag_entry);                                          \
  })
// As above, but look up via resource ID instead of string
#define ASSERT_ID_VALUES(table, id, expected)                      \
  ({                                                               \
    android::Res_value __actual_value;                             \
    EXPECT_EQ((table).getResource((id), &__actual_value), 0);      \
    EXPECT_EQ((expected).value.size, __actual_value.size);         \
    EXPECT_EQ((expected).value.dataType, __actual_value.dataType); \
    EXPECT_EQ((expected).value.data, __actual_value.data);         \
  })
} // namespace

TEST(ResTable, BuildNewTable) {
  build_arsc_file_and_validate(
      [&](const std::string& /* unused */, const std::string& arsc_path) {
        // Now, use unforked AOSP APIs to read out the data to make sure it
        // matches the stuff we put in.
        auto built_arsc_file = RedexMappedFile::open(arsc_path);
        android::ResTable built_arsc_table;
        EXPECT_EQ(built_arsc_table.add(built_arsc_file.const_data(),
                                       built_arsc_file.size()),
                  0)
            << "Could not read built data!";
        // 0x7f010000
        ASSERT_ENTRY_VALUES(built_arsc_table, "foo:dimen/first", e0);
        // 0x7f010001
        ASSERT_ENTRY_VALUES(built_arsc_table, "foo:dimen/second", e1);
        // 0x7f010002
        ASSERT_ENTRY_VALUES(built_arsc_table, "foo:dimen/third", e2);
        // Rotate to landscape should get different values for entry 0x7f010000
        built_arsc_table.setParameters(&land_config);
        ASSERT_ENTRY_VALUES(built_arsc_table, "foo:dimen/first", e0_land);
        // This one should resolve to same value as 0x7f010001 before, even in
        // landscape mode
        ASSERT_ENTRY_VALUES(built_arsc_table, "foo:dimen/second", e1);
        // Use the crazy APIs for reading plurals, styles, etc.
        ASSERT_MAP_ENTRY_VALUES(built_arsc_table, "foo:style/fourth", style);
      });
}

TEST(ResTable, DeleteAllEntriesInType) {
  build_arsc_file_and_validate(
      [&](const std::string& /* unused */, const std::string& arsc_path) {
        // Delete everything in the style type.
        delete_resources(arsc_path, {0x7f020000});
        // Use AOSP API to make sure the table is still valid after deletion.
        auto built_arsc_file = RedexMappedFile::open(arsc_path);
        android::ResTable built_arsc_table;
        EXPECT_EQ(built_arsc_table.add(built_arsc_file.const_data(),
                                       built_arsc_file.size()),
                  0)
            << "Could not read built data!";
        // 0x7f010000
        ASSERT_ENTRY_VALUES(built_arsc_table, "foo:dimen/first", e0);
        // 0x7f010001
        ASSERT_ENTRY_VALUES(built_arsc_table, "foo:dimen/second", e1);
        // 0x7f010002
        ASSERT_ENTRY_VALUES(built_arsc_table, "foo:dimen/third", e2);
        // Rotate to landscape should get different values for entry 0x7f010000
        built_arsc_table.setParameters(&land_config);
        ASSERT_ENTRY_VALUES(built_arsc_table, "foo:dimen/first", e0_land);

        // This one should have been deleted!!
        EXPECT_EQ(get_identifier(built_arsc_table, "foo:style/fourth"), 0)
            << "Style was not properly deleted!";

        // Check the validity of the string pools and ensure data is getting
        // fully cleaned up.
        {
          // Make sure the key for "fourth" got deleted.
          android::ResStringPool pool;
          EXPECT_EQ(load_key_strings(built_arsc_file, &pool), 0);
          EXPECT_EQ(pool.size(), 3);
          std::unordered_set<std::string> string_values;
          for (size_t i = 0; i < pool.size(); i++) {
            string_values.emplace(apk::get_string_from_pool(pool, i));
          }
          EXPECT_EQ(string_values.count("fourth"), 0);
          EXPECT_EQ(string_values.count("first"), 1);
          EXPECT_EQ(string_values.count("second"), 1);
          EXPECT_EQ(string_values.count("third"), 1);
        }
        {
          // We do not yet delete the type names, for now just validate that
          // dimen is still here.
          android::ResStringPool pool;
          EXPECT_EQ(load_type_strings(built_arsc_file, &pool), 0);
          std::unordered_set<std::string> string_values;
          for (size_t i = 0; i < pool.size(); i++) {
            string_values.emplace(apk::get_string_from_pool(pool, i));
          }
          EXPECT_EQ(string_values.count("dimen"), 1);
        }

        // Ensure that we have only 1 ResTable_typeSpec, but two configs within.
        auto type_infos = load_types(built_arsc_file);
        EXPECT_EQ(type_infos.size(), 1) << "ResTable_typeSpec not cleaned up!";
        EXPECT_EQ(type_infos.at(0).configs.size(), 2);
      });
}

TEST(ResTable, DeleteAllLandscapeEntries) {
  build_arsc_file_and_validate(
      [&](const std::string& /* unused */, const std::string& arsc_path) {
        // Delete the lone dimen entry that has a landscape override.
        delete_resources(arsc_path, {0x7f010000});
        // Use AOSP API to make sure the table is still valid after deletion.
        auto built_arsc_file = RedexMappedFile::open(arsc_path);
        android::ResTable built_arsc_table;
        EXPECT_EQ(built_arsc_table.add(built_arsc_file.const_data(),
                                       built_arsc_file.size()),
                  0)
            << "Could not read built data!";

        // This one should have been deleted!!
        EXPECT_EQ(get_identifier(built_arsc_table, "foo:dimen/first"), 0)
            << "Entry was not properly deleted!";

        ASSERT_ENTRY_VALUES(built_arsc_table, "foo:dimen/second", e1);
        ASSERT_ENTRY_VALUES(built_arsc_table, "foo:dimen/third", e2);
        ASSERT_MAP_ENTRY_VALUES(built_arsc_table, "foo:style/fourth", style);

        // Deleting the resource should ensure that no ResTable_type for
        // landscape config was emitted. We should still have two
        // ResTable_typeSpec structs though.
        auto type_infos = load_types(built_arsc_file);
        EXPECT_EQ(type_infos.size(), 2);
        EXPECT_EQ(type_infos.at(0).configs.size(), 1)
            << "ResTable_type not cleaned up!";
        EXPECT_EQ(type_infos.at(1).configs.size(), 1);
      });
}

TEST(ResTable, SerializeTypeWithAllEmpty) {
  auto pool_flags = android::ResStringPool_header::UTF8_FLAG;
  auto global_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  auto key_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  auto type_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  std::string type_name("dimen");
  type_strings_builder->add_string(type_name.c_str(), type_name.size());

  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(key_strings_builder);
  package_builder->set_type_strings(type_strings_builder);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(global_strings_builder);
  table_builder->add_package(package_builder);

  // Make a dimen type that is entirely full of empty things
  std::vector<android::ResTable_config*> dimen_configs = {&default_config};
  std::vector<uint32_t> dimen_flags = {0, 0, 0};
  auto dimen_type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 1, dimen_configs, dimen_flags);
  package_builder->add_type(dimen_type_definer);
  dimen_type_definer->add_empty(&default_config);
  dimen_type_definer->add_empty(&default_config);
  dimen_type_definer->add_empty(&default_config);

  // Write to a file, which should be omitting the ResTable_typeSpec and
  // ResTable_type!
  android::Vector<char> out;
  table_builder->serialize(&out);

  auto tmp_dir =
      redex::make_tmp_dir("ResTable_SerializeTypeWithAllEmpty%%%%%%%%");
  auto dest_file_path = tmp_dir.path + "/resources.arsc";
  write_to_file(dest_file_path, out);

  auto build_arsc_file = RedexMappedFile::open(dest_file_path);
  apk::TableParser parser;
  parser.visit((void*)build_arsc_file.const_data(), build_arsc_file.size());
  // Make sure there are no type structures (actual assert is a little wishy
  // washy here cause representing empty data could sensibly be done in
  // different ways).
  EXPECT_TRUE(parser.m_package_types.empty() ||
              parser.m_package_types.begin()->second.empty())
      << "Should not emit type headers for empty data";

  // Final check, make sure Android APIs can parse the table with no types.
  android::ResTable built_arsc_table;
  EXPECT_EQ(built_arsc_table.add(build_arsc_file.const_data(),
                                 build_arsc_file.size()),
            0)
      << "Could not read table!";
}

namespace {

void build_table_with_ids(const std::string& dest_file_path,
                          bool canonical_entries) {
  auto pool_flags = android::ResStringPool_header::UTF8_FLAG;
  auto global_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  auto key_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  std::vector<std::string> key_strings = {"foo", "name_removed", "bar"};
  for (const auto& s : key_strings) {
    key_strings_builder->add_string(s.c_str(), s.size());
  }
  auto type_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  std::string type_name("id");
  type_strings_builder->add_string(type_name.c_str(), type_name.size());

  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(key_strings_builder);
  package_builder->set_type_strings(type_strings_builder);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(global_strings_builder);
  table_builder->add_package(package_builder);

  // Make a dimen type that is entirely full of empty things
  std::vector<android::ResTable_config*> id_configs = {&default_config};
  std::vector<uint32_t> flags = {0, 0, 0, 0, 0, 0};
  auto type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 1, id_configs, flags, canonical_entries);
  package_builder->add_type(type_definer);
  type_definer->add(&default_config, {(uint8_t*)&id_0, sizeof(EntryAndValue)});
  // When canonical_entries is true, following three items will generate three
  // offsets that point to just a single copy of the 16 entry/value bytes.
  type_definer->add(&default_config, {(uint8_t*)&id_1, sizeof(EntryAndValue)});
  type_definer->add(&default_config, {(uint8_t*)&id_1, sizeof(EntryAndValue)});
  type_definer->add(&default_config, {(uint8_t*)&id_1, sizeof(EntryAndValue)});
  // When canonical_entries is true, following two items will generate two
  // offsets that point to just a single copy of the 16 entry/value bytes.
  type_definer->add(&default_config, {(uint8_t*)&id_2, sizeof(EntryAndValue)});
  type_definer->add(&default_config, {(uint8_t*)&id_2, sizeof(EntryAndValue)});

  android::Vector<char> out;
  table_builder->serialize(&out);
  write_to_file(dest_file_path, out);
}

} // namespace

TEST(ResTable, ValueEquality) {
  auto pool_flags = android::ResStringPool_header::UTF8_FLAG;
  auto global_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  auto key_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  auto type_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  key_strings_builder->add_string("foo");
  type_strings_builder->add_string("dimen");

  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(key_strings_builder);
  package_builder->set_type_strings(type_strings_builder);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(global_strings_builder);
  table_builder->add_package(package_builder);

  std::vector<android::ResTable_config*> dimen_configs = {
      &default_config, &land_config, &xxhdpi_config};
  std::vector<uint32_t> dimen_flags = {0, 0, 0, 0, 0};
  auto type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 1, dimen_configs, dimen_flags);
  package_builder->add_type(type_definer);

  EntryAndValue a(0, android::Res_value::TYPE_INT_COLOR_RGB8, 123456);
  EntryAndValue b(0, android::Res_value::TYPE_INT_COLOR_ARGB8, 123456);

  EntryAndValue x(0, android::Res_value::TYPE_DIMENSION, 100);
  EntryAndValue y(0, android::Res_value::TYPE_FRACTION, 200);
  EntryAndValue z(0, android::Res_value::TYPE_INT_DEC, 666);

  // 0x7f010000
  type_definer->add_empty(&default_config);
  type_definer->add(&land_config, {(uint8_t*)&a, sizeof(EntryAndValue)});
  type_definer->add(&xxhdpi_config, {(uint8_t*)&b, sizeof(EntryAndValue)});
  // 0x7f010001, make it the reverse of the above (not equal)
  type_definer->add_empty(&default_config);
  type_definer->add(&land_config, {(uint8_t*)&b, sizeof(EntryAndValue)});
  type_definer->add(&xxhdpi_config, {(uint8_t*)&a, sizeof(EntryAndValue)});
  // 0x7f010002
  type_definer->add(&default_config, {(uint8_t*)&x, sizeof(EntryAndValue)});
  type_definer->add(&land_config, {(uint8_t*)&y, sizeof(EntryAndValue)});
  type_definer->add(&xxhdpi_config, {(uint8_t*)&z, sizeof(EntryAndValue)});
  // 0x7f010003
  type_definer->add_empty(&default_config);
  type_definer->add(&land_config, {(uint8_t*)&b, sizeof(EntryAndValue)});
  type_definer->add_empty(&xxhdpi_config);
  // 0x7f010004, should be equal to 0x7f010002
  type_definer->add(&default_config, {(uint8_t*)&x, sizeof(EntryAndValue)});
  type_definer->add(&land_config, {(uint8_t*)&y, sizeof(EntryAndValue)});
  type_definer->add(&xxhdpi_config, {(uint8_t*)&z, sizeof(EntryAndValue)});

  android::Vector<char> out;
  table_builder->serialize(&out);

  auto tmp_dir = redex::make_tmp_dir("ResTable_ValueEquality%%%%%%%%");
  auto dest_file_path = tmp_dir.path + "/resources.arsc";
  write_to_file(dest_file_path, out);
  ResourcesArscFile arsc_file(dest_file_path);

  // Obvious sanity checks
  EXPECT_TRUE(arsc_file.resource_value_identical(0x7f010000, 0x7f010000));
  EXPECT_TRUE(arsc_file.resource_value_identical(0x7f010001, 0x7f010001));
  EXPECT_TRUE(arsc_file.resource_value_identical(0x7f010002, 0x7f010002));
  EXPECT_TRUE(arsc_file.resource_value_identical(0x7f010003, 0x7f010003));
  EXPECT_TRUE(arsc_file.resource_value_identical(0x7f010004, 0x7f010004));

  // Real checks
  EXPECT_TRUE(arsc_file.resource_value_identical(0x7f010002, 0x7f010004));

  EXPECT_FALSE(arsc_file.resource_value_identical(0x7f010000, 0x7f010001));
  EXPECT_FALSE(arsc_file.resource_value_identical(0x7f010000, 0x7f010002));
  EXPECT_FALSE(arsc_file.resource_value_identical(0x7f010001, 0x7f010002));
  EXPECT_FALSE(arsc_file.resource_value_identical(0x7f010002, 0x7f010003));
}

TEST(ResTable, CanonicalEntryData) {
  auto do_validation = [&](const std::string& file_path,
                           uint32_t type_expected_size) {
    auto file = RedexMappedFile::open(file_path);
    android::ResTable arsc_table;
    EXPECT_EQ(arsc_table.add(file.const_data(), file.size()), 0)
        << "Could not read table!";
    ASSERT_ID_VALUES(arsc_table, 0x7f010000, id_0);
    ASSERT_ID_VALUES(arsc_table, 0x7f010001, id_1);
    ASSERT_ID_VALUES(arsc_table, 0x7f010002, id_1);
    ASSERT_ID_VALUES(arsc_table, 0x7f010003, id_1);
    ASSERT_ID_VALUES(arsc_table, 0x7f010004, id_2);
    ASSERT_ID_VALUES(arsc_table, 0x7f010005, id_2);

    // Assert the size of the ResTable_type for the id table
    apk::TableParser parser;
    parser.visit((void*)file.const_data(), file.size());
    auto type_info = parser.m_package_types.begin()->second.at(0);
    EXPECT_EQ(type_info.configs.at(0)->header.size, type_expected_size)
        << "ResTable_type was not expected size!";
  };

  uint32_t num_entries = 6;
  uint32_t expected_size_no_canon = sizeof(android::ResTable_type) +
                                    num_entries * sizeof(uint32_t) +
                                    num_entries * sizeof(EntryAndValue);
  // Three of these things are duplicated, but the offsets will remain.
  uint32_t expected_size_canon =
      expected_size_no_canon - 3 * sizeof(EntryAndValue);

  auto tmp_dir = redex::make_tmp_dir("ResTable_CanonicalEntryData%%%%%%%%");

  auto no_canonical_path = tmp_dir.path + "/no_canon.arsc";
  build_table_with_ids(no_canonical_path, false);
  do_validation(no_canonical_path, expected_size_no_canon);

  auto canonical_path = tmp_dir.path + "/canon.arsc";
  build_table_with_ids(canonical_path, true);
  do_validation(canonical_path, expected_size_canon);

  // Make sure the Projector also emits the data properly in canonical form. Do
  // this by taking the non-canonical table, as prepared by the Definer, and
  // copy it all into a new builder using the Projector with the
  // "enable_canonical_entries" flag flipped to true.
  auto no_canon_file = RedexMappedFile::open(no_canonical_path);
  apk::TableParser parsed_table;
  parsed_table.visit((void*)no_canon_file.const_data(), no_canon_file.size());
  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(
      parsed_table.m_package_key_string_headers.begin()->second);
  package_builder->set_type_strings(
      parsed_table.m_package_type_string_headers.begin()->second);

  auto& id_type = parsed_table.m_package_types.begin()->second.at(0);
  auto type_projector = std::make_shared<arsc::ResTableTypeProjector>(
      package_header.id, id_type.spec, id_type.configs, true);
  package_builder->add_type(type_projector);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(parsed_table.m_global_pool_header);
  table_builder->add_package(package_builder);
  android::Vector<char> out;
  table_builder->serialize(&out);

  auto projector_canon_path = tmp_dir.path + "/projector_canon.arsc";
  write_to_file(projector_canon_path, out);
  do_validation(projector_canon_path, expected_size_canon);
}

TEST(ResTable, GetStringsByName) {
  // Make the strangest hypothetical table that could exist (string with values
  // in multiple configs, references with cycles, etc).
  auto pool_flags = android::ResStringPool_header::UTF8_FLAG;
  auto global_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  global_strings_builder->add_string("a");
  global_strings_builder->add_string("b");
  global_strings_builder->add_string("c");
  global_strings_builder->add_string("d");
  global_strings_builder->add_string("e");
  auto key_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  key_strings_builder->add_string("first");
  key_strings_builder->add_string("second");
  key_strings_builder->add_string("third");
  key_strings_builder->add_string("fourth");
  auto type_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  type_strings_builder->add_string("string");

  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(key_strings_builder);
  package_builder->set_type_strings(type_strings_builder);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(global_strings_builder);
  table_builder->add_package(package_builder);

  std::vector<android::ResTable_config*> string_configs = {&default_config,
                                                           &land_config};
  std::vector<uint32_t> string_flags = {
      0, android::ResTable_config::CONFIG_ORIENTATION,
      android::ResTable_config::CONFIG_ORIENTATION,
      android::ResTable_config::CONFIG_ORIENTATION};
  auto type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 1, string_configs, string_flags);
  package_builder->add_type(type_definer);

  EntryAndValue first(0, android::Res_value::TYPE_STRING, 0);
  type_definer->add(&default_config, {(uint8_t*)&first, sizeof(EntryAndValue)});
  type_definer->add_empty(&land_config);

  EntryAndValue second(1, android::Res_value::TYPE_STRING, 1);
  EntryAndValue second_land(1, android::Res_value::TYPE_STRING, 2);
  type_definer->add(&default_config,
                    {(uint8_t*)&second, sizeof(EntryAndValue)});
  type_definer->add(&land_config,
                    {(uint8_t*)&second_land, sizeof(EntryAndValue)});

  // These next two entries are diabolical as some of their entries will be
  // cyclic.
  EntryAndValue third(2, android::Res_value::TYPE_STRING, 3);
  EntryAndValue third_land(2, android::Res_value::TYPE_REFERENCE, 0x7f010003);
  type_definer->add(&default_config, {(uint8_t*)&third, sizeof(EntryAndValue)});
  type_definer->add(&land_config,
                    {(uint8_t*)&third_land, sizeof(EntryAndValue)});

  EntryAndValue fourth(3, android::Res_value::TYPE_REFERENCE, 0x7f010002);
  EntryAndValue fourth_land(3, android::Res_value::TYPE_STRING, 4);
  type_definer->add(&default_config,
                    {(uint8_t*)&fourth, sizeof(EntryAndValue)});
  type_definer->add(&land_config,
                    {(uint8_t*)&fourth_land, sizeof(EntryAndValue)});

  android::Vector<char> out;
  table_builder->serialize(&out);

  auto tmp_dir = redex::make_tmp_dir("ResTable_GetStringsByName%%%%%%%%");
  auto arsc_path = tmp_dir.path + "/resources.arsc";
  write_to_file(arsc_path, out);

  ResourcesArscFile arsc_file(arsc_path);
  auto vec = arsc_file.get_resource_strings_by_name("first");
  EXPECT_EQ(vec.size(), 1);
  EXPECT_STREQ(vec[0].c_str(), "a");
  vec = arsc_file.get_resource_strings_by_name("second");
  EXPECT_EQ(vec.size(), 2);
  EXPECT_STREQ(vec[0].c_str(), "b");
  EXPECT_STREQ(vec[1].c_str(), "c");
  vec = arsc_file.get_resource_strings_by_name("third");
  EXPECT_EQ(vec.size(), 2);
  EXPECT_STREQ(vec[0].c_str(), "d");
  EXPECT_STREQ(vec[1].c_str(), "e");
  vec = arsc_file.get_resource_strings_by_name("blah");
  EXPECT_EQ(vec.size(), 0);
}
