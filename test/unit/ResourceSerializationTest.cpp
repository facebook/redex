/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <array>
#include <boost/process/args.hpp>
#include <boost/process/child.hpp>
#include <boost/process/io.hpp>
#include <boost/regex.hpp>
#include <fstream>
#include <gtest/gtest.h>

#include "ApkResources.h"
#include "Debug.h"
#include "RedexMappedFile.h"
#include "RedexResources.h"
#include "RedexTestUtils.h"
#include "SanitizersConfig.h"
#include "Util.h"
#include "androidfw/ResourceTypes.h"
#include "utils/Serialize.h"
#include "utils/Visitor.h"

namespace {
// Chunk of just the ResStringPool, as generated by aapt2 (has 2 UTF8 strings)
const std::array<uint8_t, 84> example_data_8{
    {0x01, 0x00, 0x1C, 0x00, 0x54, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
     0x0C, 0x0C, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x77, 0x6F, 0x72,
     0x6C, 0x64, 0x00, 0x1C, 0x1C, 0x72, 0x65, 0x73, 0x2F, 0x6C, 0x61, 0x79,
     0x6F, 0x75, 0x74, 0x2F, 0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x5F, 0x6C,
     0x61, 0x79, 0x6F, 0x75, 0x74, 0x2E, 0x78, 0x6D, 0x6C, 0x00, 0x00, 0x00}};

// Another aapt2 generated ResStringPool, encoded as UTF-16.
const std::array<uint8_t, 116> example_data_16{
    {0x01, 0x00, 0x1C, 0x00, 0x74, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00,
     0x1C, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
     0x05, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6C, 0x00, 0x6F, 0x00, 0x72, 0x00,
     0x00, 0x00, 0x05, 0x00, 0x64, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x65, 0x00,
     0x6E, 0x00, 0x00, 0x00, 0x02, 0x00, 0x69, 0x00, 0x64, 0x00, 0x00, 0x00,
     0x06, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x79, 0x00, 0x6F, 0x00, 0x75, 0x00,
     0x74, 0x00, 0x00, 0x00, 0x06, 0x00, 0x73, 0x00, 0x74, 0x00, 0x72, 0x00,
     0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x00, 0x00}};

std::string make_big_string(size_t len) {
  always_assert(len > 4);
  std::string result = "aa" + std::string(len - 4, 'x') + "zz";
  return result;
}

UNUSED void assert_u16_string(const std::u16string& actual_str,
                              const std::string& expected) {
  std::u16string expected_str(expected.begin(), expected.end());
  ASSERT_EQ(actual_str, expected_str);
}

void assert_serialized_data(const void* original,
                            size_t length,
                            android::Vector<char>& serialized) {
  ASSERT_EQ(length, serialized.size());
  for (size_t i = 0; i < length; i++) {
    auto actual = *((const char*)original + i);
    ASSERT_EQ(actual, serialized[i]) << "Mismatch at offset " << i;
  }
}

void copy_file(const std::string& from, const std::string& to) {
  std::ifstream src_stream(from, std::ios::binary);
  std::ofstream dest_stream(to, std::ios::binary);
  dest_stream << src_stream.rdbuf();
}

bool are_files_equal(const std::string& p1, const std::string& p2) {
  std::ifstream f1(p1, std::ifstream::binary | std::ifstream::ate);
  std::ifstream f2(p2, std::ifstream::binary | std::ifstream::ate);
  always_assert_log(!f1.fail(), "Failed to read path %s", p1.c_str());
  always_assert_log(!f2.fail(), "Failed to read path %s", p2.c_str());
  if (f1.tellg() != f2.tellg()) {
    std::cerr << "File length mismatch. " << f1.tellg() << " != " << f2.tellg()
              << std::endl;
    return false;
  }
  f1.seekg(0, std::ifstream::beg);
  f2.seekg(0, std::ifstream::beg);
  return std::equal(std::istreambuf_iterator<char>(f1.rdbuf()),
                    std::istreambuf_iterator<char>(),
                    std::istreambuf_iterator<char>(f2.rdbuf()));
}

void write_to_file(const std::string& output_path,
                   android::Vector<char>& data) {
  std::ofstream fout(output_path,
                     std::ios::out | std::ios::binary | std::ios::trunc);
  always_assert_log(fout.is_open(), "Could not open path %s for writing",
                    output_path.c_str());
  fout.write(data.array(), data.size());
  fout.close();
}

// Runs `aapt d --values resources <an .apk file>` against a zip file containing
// the given .arsc file. If successful, stdout will be returned. This ensures
// that the Android SDK tools can successfully parse our built .arsc files, even
// with all our shenanigans going on :) ;)
std::vector<std::string> aapt_dump_helper(const std::string& arsc_path) {
  std::string arsc_dumper_bin(std::getenv("arsc_dumper_bin"));
  boost::process::ipstream is;
  boost::process::child c(
      arsc_dumper_bin,
      boost::process::args(
          {"--aapt", std::getenv("aapt_path"), "--arsc", arsc_path.c_str()}),
      boost::process::std_out > is);

  std::vector<std::string> data;
  std::string line;
  while (c.running() && std::getline(is, line) && !line.empty()) {
    data.push_back(line);
  }
  c.wait();
  auto exit_code = c.exit_code();
  if (exit_code != 0) {
    throw std::runtime_error("aapt dump failed with exit code " +
                             std::to_string(exit_code));
  }
  return data;
}

struct SimpleEntry {
  uint32_t id;
  std::string name;
  android::Res_value value;
};
struct ComplexValue {
  uint32_t key;
  std::string kind;
  uint32_t data;
};
struct ComplexEntry {
  uint32_t id;
  std::string name;
  uint32_t parent_id;
  std::vector<ComplexValue> values;
};
struct ParsedAaptOutput {
  std::string package_name;
  std::map<uint32_t, uint32_t> flags;
  std::map<uint32_t, std::string> id_fully_qualified_names;
  std::map<std::string, uint32_t> fully_qualified_name_to_id;
  std::map<std::string, std::map<uint32_t, SimpleEntry>>
      config_to_simple_values;
  std::map<std::string, std::map<uint32_t, ComplexEntry>>
      config_to_complex_values;

  android::Res_value get_simple_value(const std::string& config, uint32_t id) {
    if (config_to_simple_values.count(config) == 0) {
      throw std::runtime_error("no simple values for config: " + config);
    }
    auto& map = config_to_simple_values.at(config);
    if (map.count(id) == 0) {
      std::stringstream ss;
      ss << "no data for ID 0x" << std::hex << id << " in config: " << config;
      throw std::runtime_error(ss.str());
    }
    auto& entry = map.at(id);
    return entry.value;
  }

  std::vector<ComplexValue> get_complex_values(const std::string& config,
                                               uint32_t id) {
    if (config_to_complex_values.count(config) == 0) {
      throw std::runtime_error("no complex values for config: " + config);
    }
    auto& map = config_to_complex_values.at(config);
    if (map.count(id) == 0) {
      std::stringstream ss;
      ss << "no data for ID 0x" << std::hex << id << " in config: " << config;
      throw std::runtime_error(ss.str());
    }
    auto& entry = map.at(id);
    return entry.values;
  }

  uint32_t get_identifier(const std::string& fully_qualified) {
    if (fully_qualified_name_to_id.count(fully_qualified) == 0) {
      std::cerr << "No ID found for " << fully_qualified << std::endl;
      return 0;
    }
    return fully_qualified_name_to_id.at(fully_qualified);
  }
};

std::string value_to_type_string(const android::Res_value& value) {
  if (value.dataType == android::Res_value::TYPE_NULL) {
    if (value.data == android::Res_value::DATA_NULL_EMPTY) {
      return "null empty";
    } else {
      return "null";
    }
  } else if (value.dataType == android::Res_value::TYPE_REFERENCE) {
    return "reference";
  } else if (value.dataType == android::Res_value::TYPE_DYNAMIC_REFERENCE) {
    return "dynamic reference";
  } else if (value.dataType == android::Res_value::TYPE_ATTRIBUTE) {
    return "attribute";
  } else if (value.dataType == android::Res_value::TYPE_STRING) {
    return "string8"; // this is an assumption but whatever, good enough
  } else if (value.dataType == android::Res_value::TYPE_FLOAT) {
    return "float";
  } else if (value.dataType == android::Res_value::TYPE_DIMENSION) {
    return "dimension";
  } else if (value.dataType == android::Res_value::TYPE_FRACTION) {
    return "fraction";
  } else if (value.dataType >= android::Res_value::TYPE_FIRST_COLOR_INT &&
             value.dataType <= android::Res_value::TYPE_LAST_COLOR_INT) {
    return "color";
  } else if (value.dataType == android::Res_value::TYPE_INT_BOOLEAN) {
    return "boolean";
  } else if (value.dataType >= android::Res_value::TYPE_FIRST_INT &&
             value.dataType <= android::Res_value::TYPE_LAST_INT) {
    return "int";
  } else {
    return "unknown type";
  }
}

// Reads the text output of the form P501204390. aapt d is kind of crappy in
// that it does not print complex values in a nice form (we have to change
// representation to string for types, which is annoying).
// FYI the implementation of the printer is here in case you need to consult it
// or change this in future sdk versions:
// https://cs.android.com/android/platform/superproject/+/android-12.0.0_r1:frameworks/base/libs/androidfw/ResourceTypes.cpp;l=7544
ParsedAaptOutput aapt_dump_and_parse(const std::string& arsc_path,
                                     bool verbose = false) {
  ParsedAaptOutput output;
  boost::regex package_exp{
      "^Package Group 0 id=0x7f packageCount=1 name=(.*)$"};
  boost::regex spec_exp{
      "^[ ]*spec resource 0x([0-9a-fA-F]+)[^=]+=0x([0-9a-fA-F]+)$"};
  boost::regex config_exp{"^[ ]*config ([^:]+):$"};
  // Capture the id, package, type/entry, value type, data.
  // Size and r0 are intentionally not captured as we know their hard coded
  // value ahead of time. If they differ, we will not match and fail the test.
  boost::regex simple_exp{
      "^[ ]*resource 0x([0-9a-fA-F]+) ([^:]+):([^:]+): t=0x([0-9a-fA-F]+) "
      "d=0x([0-9a-fA-F]+)..s=0x0008 r=0x00.$"};
  boost::regex bag_exp{
      "^[ ]*resource 0x([0-9a-fA-F]+) ([^:]+):([^:]+): .bag.$"};
  boost::regex bag_parent_exp{"^[ ]*Parent=0x([0-9a-fA-F]+).*$"};
  boost::regex bag_value_exp{
      "^[ ]*#[0-9]+ .Key=0x([0-9a-fA-F]+).: .([a-z0-9 ]+). #([0-9a-fA-F]+)$"};

  auto lines = aapt_dump_helper(arsc_path);
  std::string current_config("");
  enum ComplexState { Unknown, Begin, Values };
  ComplexState state = Unknown;
  // complex_entries[complex_entries.size() - 1] is the entry we're working on
  // that takes multiple lines to complete.
  std::vector<ComplexEntry> complex_entries;
  auto maybe_handle_complex = [&]() {
    if (state == Values) {
      auto& complex_values = output.config_to_complex_values[current_config];
      auto& entry = complex_entries[complex_entries.size() - 1];
      complex_values.emplace(entry.id, entry);
    }
    state = Unknown;
  };
  for (const auto& line : lines) {
    if (verbose) {
      std::cerr << line << std::endl;
    }
    boost::smatch what;
    if (output.package_name.empty() &&
        boost::regex_search(line, what, package_exp)) {
      output.package_name = what[1];
    } else if (boost::regex_search(line, what, spec_exp)) {
      maybe_handle_complex();
      uint32_t id = std::stoul(what[1], nullptr, 16);
      uint32_t flags = std::stoul(what[2], nullptr, 16);
      output.flags.emplace(id, flags);
    } else if (boost::regex_search(line, what, config_exp)) {
      maybe_handle_complex();
      auto name = what[1].str();
      if (strcmp(name.c_str(), "(default)") == 0) {
        current_config = "default";
      } else {
        current_config = name;
      }
    } else if (boost::regex_search(line, what, simple_exp)) {
      maybe_handle_complex();
      auto& simple_values = output.config_to_simple_values[current_config];
      uint32_t id = std::stoul(what[1], nullptr, 16);
      auto fully_qualified = what[2].str() + ":" + what[3].str();
      uint32_t type = std::stoul(what[4], nullptr, 16);
      if (type > android::Res_value::TYPE_LAST_INT) {
        std::cerr << "Bad type: " << line << std::endl;
        continue;
      }
      uint32_t data = std::stoul(what[5], nullptr, 16);
      output.id_fully_qualified_names.emplace(id, fully_qualified);
      output.fully_qualified_name_to_id.emplace(fully_qualified, id);
      android::Res_value value{
          sizeof(android::Res_value), 0, (uint8_t)type, {data}};
      SimpleEntry entry{id, fully_qualified, value};
      simple_values.emplace(id, std::move(entry));
    } else if (boost::regex_search(line, what, bag_exp)) {
      maybe_handle_complex();
      state = Begin;
      ComplexEntry entry{};
      entry.id = std::stoul(what[1], nullptr, 16);
      entry.name = what[2].str() + ":" + what[3].str();
      output.id_fully_qualified_names.emplace(entry.id, entry.name);
      output.fully_qualified_name_to_id.emplace(entry.name, entry.id);
      complex_entries.emplace_back(std::move(entry));
    } else if (boost::regex_search(line, what, bag_parent_exp)) {
      always_assert_log(state == Begin, "Unexpected state at line: %s",
                        line.c_str());
      auto& entry = complex_entries[complex_entries.size() - 1];
      entry.parent_id = std::stoul(what[1], nullptr, 16);
      state = Values;
    } else if (boost::regex_search(line, what, bag_value_exp)) {
      always_assert_log(state == Values, "Unexpected state at line: %s",
                        line.c_str());
      ComplexValue value{(uint32_t)std::stoul(what[1], nullptr, 16), what[2],
                         (uint32_t)std::stoul(what[3], nullptr, 16)};
      auto& entry = complex_entries[complex_entries.size() - 1];
      entry.values.emplace_back(std::move(value));
    }
  }
  maybe_handle_complex();

  // End of parsing, optionally spew our representation to stderr.
  if (verbose) {
    std::cerr << "Dumping parsed package: " << output.package_name << std::endl
              << "IDs (" << output.id_fully_qualified_names.size()
              << "):" << std::endl;
    for (auto& pair : output.id_fully_qualified_names) {
      std::cerr << "  0x" << std::hex << pair.first << std::dec << " ("
                << pair.second << ")" << std::endl;
    }
    std::cerr << "Flags (" << output.flags.size() << "):" << std::endl;
    for (auto& pair : output.flags) {
      std::cerr << "  0x" << std::hex << pair.first << " -> 0x" << pair.second
                << std::dec << std::endl;
    }
    std::cerr << "Simple entries:" << std::endl;
    for (auto& config_pair : output.config_to_simple_values) {
      std::cerr << "  config: " << config_pair.first << std::endl;
      for (auto& entry_pair : config_pair.second) {
        auto& e = entry_pair.second;
        std::cerr << "    0x" << std::hex << entry_pair.first << " (" << e.name
                  << "): "
                  << "t=0x" << unsigned(e.value.dataType) << " d=0x"
                  << e.value.data << std::dec << std::endl;
      }
    }
    std::cerr << "Complex entries:" << std::endl;
    for (auto& config_pair : output.config_to_complex_values) {
      std::cerr << "  config: " << config_pair.first << std::endl;
      for (auto& entry_pair : config_pair.second) {
        auto& e = entry_pair.second;
        std::cerr << "    0x" << std::hex << entry_pair.first << " (" << e.name
                  << "): Parent = 0x" << e.parent_id << std::dec << std::endl;
        for (auto& v : e.values) {
          std::cerr << "      key = 0x" << std::hex << v.key << " (" << v.kind
                    << "): 0x" << v.data << std::dec << std::endl;
        }
      }
    }
  }
  return output;
}
} // namespace

TEST(ResStringPool, ReplaceStringsInXmlLayout) {
  // Given layout file should have a series of View subclasses in the XML, which
  // we will rename. Parse the resulting binary data, and make sure all tags are
  // right.
  auto f = RedexMappedFile::open(std::getenv("test_layout_path"));

  std::map<std::string, std::string> shortened_names;
  shortened_names.emplace("com.example.test.CustomViewGroup", "Z.a");
  shortened_names.emplace("com.example.test.CustomTextView", "Z.b");
  shortened_names.emplace("com.example.test.CustomButton", "Z.c");
  shortened_names.emplace("com.example.test.NotFound", "Z.d");

  android::Vector<char> serialized;
  size_t num_renamed = 0;
  ApkResources resources("");
  resources.replace_in_xml_string_pool(
      f.const_data(), f.size(), shortened_names, &serialized, &num_renamed);

  EXPECT_EQ(num_renamed, 3);
  android::ResXMLTree parser;
  parser.setTo(&serialized[0], serialized.size());
  EXPECT_EQ(android::NO_ERROR, parser.getError())
      << "Error parsing layout after rename";

  std::vector<std::string> expected_xml_tags;
  expected_xml_tags.push_back("Z.a");
  expected_xml_tags.push_back("TextView");
  expected_xml_tags.push_back("Z.b");
  expected_xml_tags.push_back("Z.c");
  expected_xml_tags.push_back("Button");

  size_t tag_count = 0;
  android::ResXMLParser::event_code_t type;
  do {
    type = parser.next();
    if (type == android::ResXMLParser::START_TAG) {
      EXPECT_LT(tag_count, 5);
      size_t len;
      android::String8 tag(parser.getElementName(&len));
      auto actual_chars = tag.string();
      auto expected_chars = expected_xml_tags[tag_count].c_str();
      EXPECT_STREQ(actual_chars, expected_chars);
      tag_count++;
    }
  } while (type != android::ResXMLParser::BAD_DOCUMENT &&
           type != android::ResXMLParser::END_DOCUMENT);
  EXPECT_EQ(tag_count, 5);
}

TEST(ResTable, AppendNewType) {
  auto src_file_path = std::getenv("test_arsc_path");
  auto tmp_dir = redex::make_tmp_dir("ResTable_AppendNewType%%%%%%%%");
  auto dest_file_path = tmp_dir.path + "/resources.arsc";
  copy_file(src_file_path, dest_file_path);

  auto src = RedexMappedFile::open(src_file_path);
  // Set up existing entry data to copy into a different type
  const uint8_t dest_type = 3;
  std::vector<uint32_t> source_ids;
  source_ids.push_back(0x7f010000);
  size_t num_ids = source_ids.size();
  android::Vector<android::Res_value> values;
  // Read the number of original types.
  std::vector<std::string> original_type_names;
  {
    apk::TableSnapshot table_snapshot(src, src.size());
    table_snapshot.get_type_names(APPLICATION_PACKAGE, &original_type_names);
    for (size_t i = 0; i < num_ids; i++) {
      table_snapshot.collect_resource_values(source_ids[i], &values);
    }
  }

  // Create a default looking ResTable_config
  android::ResTable_config default_config;
  memset(&default_config, 0, sizeof(android::ResTable_config));
  default_config.size = sizeof(android::ResTable_config);

  // Write a new .arsc file
  {
    ResourcesArscFile arsc_file(dest_file_path);
    std::vector<android::ResTable_config*> config_ptrs;
    config_ptrs.emplace_back(&default_config);
    arsc_file.define_type(0x7f, 3, "foo", config_ptrs, source_ids);
    arsc_file.serialize();
  }

  auto round_trip_dump = aapt_dump_and_parse(dest_file_path);
  auto dest = RedexMappedFile::open(dest_file_path);
  apk::TableSnapshot round_trip_snapshot(dest, dest.size());
  // Make sure entries exist in 0x7f03xxxx range
  for (size_t i = 0; i < num_ids; i++) {
    auto old_id = source_ids[i];
    auto new_id = 0x7f000000 | (dest_type << 16) | (old_id & 0xFFFF);
    android::Res_value expected = values[i];
    auto actual = round_trip_dump.get_simple_value("default", new_id);
    ASSERT_EQ(expected.dataType, actual.dataType);
    ASSERT_EQ(expected.data, actual.data);
  }

  // Sanity check values in their original location
  {
    auto out_value = round_trip_dump.get_simple_value("default", 0x7f010000);
    float val = arsc::complex_value(out_value.data);
    uint32_t unit = arsc::complex_unit(out_value.data, false);
    ASSERT_EQ((int)val, 10);
    ASSERT_EQ(unit, android::Res_value::COMPLEX_UNIT_DIP);
  }
  {
    auto out_value = round_trip_dump.get_simple_value("default", 0x7f010001);
    float val = arsc::complex_value(out_value.data);
    uint32_t unit = arsc::complex_unit(out_value.data, false);
    ASSERT_EQ((int)val, 20);
    ASSERT_EQ(unit, android::Res_value::COMPLEX_UNIT_DIP);
  }

  std::vector<std::string> type_names;
  round_trip_snapshot.get_type_names(APPLICATION_PACKAGE, &type_names);
  ASSERT_EQ(type_names.size(), original_type_names.size() + 1);
}

TEST(ResStringPoolBuilder, TestPoolRebuild8) {
  android::ResStringPool pool(&example_data_8, example_data_8.size(), false);
  auto flags =
      (pool.isUTF8() ? android::ResStringPool_header::UTF8_FLAG : 0) |
      (pool.isSorted() ? android::ResStringPool_header::SORTED_FLAG : 0);
  auto pool_size = pool.size();

  arsc::ResStringPoolBuilder builder(flags);
  for (size_t i = 0; i < pool_size; i++) {
    size_t out_len;
    auto s = pool.string8At(i, &out_len);
    builder.add_string(s, out_len);
  }
  android::Vector<char> serialized;
  builder.serialize(&serialized);
  assert_serialized_data(&example_data_8, example_data_8.size(), serialized);
}

TEST(ResStringPoolBuilder, TestPoolRebuild16) {
  android::ResStringPool pool(&example_data_16, example_data_16.size(), false);
  auto flags =
      (pool.isUTF8() ? android::ResStringPool_header::UTF8_FLAG : 0) |
      (pool.isSorted() ? android::ResStringPool_header::SORTED_FLAG : 0);
  auto pool_size = pool.size();

  arsc::ResStringPoolBuilder builder(flags);
  for (size_t i = 0; i < pool_size; i++) {
    size_t out_len;
    auto s = pool.stringAt(i, &out_len);
    builder.add_string(s, out_len);
  }
  android::Vector<char> serialized;
  builder.serialize(&serialized);
  assert_serialized_data(&example_data_16, example_data_16.size(), serialized);
}

TEST(ResStringPoolBuilder, TestPoolRebuildStyle8) {
  const std::array<uint8_t, 232> data{
      {0x01, 0x00, 0x1c, 0x00, 0xe8, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
       0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
       0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
       0x41, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
       0x59, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x1c, 0x00, 0x00, 0x00, 0x11, 0x11, 0x41, 0x6e, 0x20, 0x75, 0x6e, 0x75,
       0x73, 0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x00,
       0x2a, 0x2a, 0x49, 0x20, 0x6c, 0x69, 0x6b, 0x65, 0x20, 0x61, 0x20, 0x66,
       0x69, 0x6e, 0x65, 0x20, 0x67, 0x6c, 0x61, 0x73, 0x73, 0x20, 0x6f, 0x66,
       0x20, 0x48, 0x32, 0x4f, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20,
       0x6d, 0x6f, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x21, 0x00, 0x0c, 0x0c, 0x48,
       0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x2e, 0x00,
       0x01, 0x01, 0x62, 0x00, 0x02, 0x02, 0x65, 0x6d, 0x00, 0x03, 0x03, 0x73,
       0x75, 0x62, 0x00, 0x03, 0x03, 0x73, 0x75, 0x70, 0x00, 0x00, 0x00, 0x00,
       0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
       0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
       0xff, 0xff, 0xff, 0xff, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
       0x0c, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
       0x18, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
       0xff, 0xff, 0xff, 0xff}};
  android::ResStringPool pool(&data, data.size(), false);
  auto flags =
      (pool.isUTF8() ? android::ResStringPool_header::UTF8_FLAG : 0) |
      (pool.isSorted() ? android::ResStringPool_header::SORTED_FLAG : 0);
  auto pool_size = pool.size();
  auto style_count = pool.styleCount();
  arsc::ResStringPoolBuilder builder(flags);
  for (size_t i = 0; i < pool_size; i++) {
    size_t out_len;
    auto s = pool.string8At(i, &out_len);
    if (i < style_count) {
      arsc::SpanVector vec;
      auto span = (android::ResStringPool_span*)pool.styleAt(i);
      arsc::collect_spans(span, &vec);
      builder.add_style(s, out_len, vec);
    } else {
      builder.add_string(s, out_len);
    }
  }
  EXPECT_EQ(pool.size(), builder.string_count());
  android::Vector<char> serialized;
  builder.serialize(&serialized);
  assert_serialized_data(&data, data.size(), serialized);
}

TEST(ResStringPoolBuilder, TestAllTheOptions) {
  std::string hello_world("Hello world!");
  android::String16 hello_world16("Hello world!");
  android::String8 foo("foo");
  android::String16 bar("bar");
  auto big_std_string = make_big_string(1000);
  std::string em("em");

  android::ResStringPool_span span{
      .name = {.index = 4}, .firstChar = 6, .lastChar = 10};
  std::vector<android::ResStringPool_span*> spans = {&span};

  auto do_validation = [&](void* data, size_t size) {
    android::ResStringPool pool;
    EXPECT_EQ(pool.setTo(data, size), 0);
    EXPECT_EQ(pool.styleCount(), 1);
    EXPECT_EQ(pool.size(), 5);
    EXPECT_STREQ(apk::get_string_from_pool(pool, 0).c_str(), "Hello world!");
    EXPECT_STREQ(apk::get_string_from_pool(pool, 1).c_str(), "foo");
    EXPECT_STREQ(apk::get_string_from_pool(pool, 2).c_str(), "bar");
    EXPECT_STREQ(apk::get_string_from_pool(pool, 3).c_str(),
                 big_std_string.c_str());
    EXPECT_STREQ(apk::get_string_from_pool(pool, 4).c_str(), "em");
  };

  {
    arsc::ResStringPoolBuilder builder(0);
    builder.add_style(hello_world, spans);
    builder.add_string(foo.string(), foo.size());
    builder.add_string(bar.string(), bar.size());
    builder.add_string(big_std_string);
    builder.add_string(em);

    android::Vector<char> out;
    builder.serialize(&out);
    do_validation((void*)out.array(), out.size());
  }
  {
    arsc::ResStringPoolBuilder builder(
        android::ResStringPool_header::UTF8_FLAG);
    builder.add_style(hello_world16.string(), hello_world16.size(), spans);
    builder.add_string(foo.string(), foo.size());
    builder.add_string(bar.string(), bar.size());
    builder.add_string(big_std_string);
    builder.add_string(em);

    android::Vector<char> out;
    builder.serialize(&out);
    do_validation((void*)out.array(), out.size());
  }
}

TEST(ResTableParse, TestUnknownPackageChunks) {
  // A table with one package, which has a fake chunk that is made up. The chunk
  // that is not known/recognized should just be copied as-is to the output.
  auto tmp_dir = redex::make_tmp_dir("ResTableParse%%%%%%%%");
  auto res_path = tmp_dir.path + "/resources.arsc";
  copy_file(std::getenv("resources_unknown_chunk"), res_path);
  ResourcesArscFile res_table(res_path);
  res_table.remove_unreferenced_strings();
  EXPECT_TRUE(
      are_files_equal(std::getenv("resources_unknown_chunk"), res_path));
}

TEST(Configs, TestConfigEquivalence) {
  android::ResTable_config default_config{};
  default_config.size = sizeof(android::ResTable_config);
  EXPECT_TRUE(arsc::are_configs_equivalent(&default_config, &default_config));
  android::ResTable_config land_config{};
  land_config.size = sizeof(android::ResTable_config);
  land_config.orientation = android::ResTable_config::ORIENTATION_LAND;
  EXPECT_FALSE(arsc::are_configs_equivalent(&default_config, &land_config));
  // Configs of different sizes (simulate some of our snapshots of older files)
  {
    struct SmallConfig {
      uint32_t a;
      uint32_t b;
      uint32_t c;
      uint32_t d;
    };
    SmallConfig small_config{};
    small_config.a = sizeof(SmallConfig);
    EXPECT_TRUE(arsc::are_configs_equivalent(
        &default_config, (android::ResTable_config*)&small_config));
  }
  {
    PACKED(struct BiggerConfig {
      android::ResTable_config config{};
      uint32_t a;
      uint32_t b;
      uint32_t c;
      uint32_t d;
    });
    BiggerConfig big_config{};
    big_config.config = default_config;
    big_config.config.size = sizeof(BiggerConfig);
    // Can't determine default values of newer versions we don't know about.
    EXPECT_FALSE(arsc::are_configs_equivalent(
        &default_config, (android::ResTable_config*)&big_config));
  }
}

TEST(ResTable, TestBuilderRoundTrip) {
  auto tmp_dir = redex::make_tmp_dir("ResTable%%%%%%%%");
  auto res_path = tmp_dir.path + "/resources.arsc";
  copy_file(std::getenv("test_arsc_path"), res_path);
  ResourcesArscFile res_table(res_path);
  res_table.serialize();
  EXPECT_TRUE(are_files_equal(std::getenv("test_arsc_path"), res_path));
}

namespace {
PACKED(struct EntryAndValue {
  android::ResTable_entry entry{};
  android::Res_value value{};
  EntryAndValue(uint32_t key_string_idx, uint8_t data_type, uint32_t data) {
    entry.size = sizeof(android::ResTable_entry);
    entry.key.index = key_string_idx;
    value.size = sizeof(android::Res_value);
    value.dataType = data_type;
    value.data = data;
  }
});

// For testing simplicity, a map that has two items in it.
PACKED(struct MapEntryAndValues {
  android::ResTable_map_entry entry{};
  android::ResTable_map item0{};
  android::ResTable_map item1{};
  MapEntryAndValues(uint32_t key_string_idx, uint32_t parent_ident) {
    entry.size = sizeof(android::ResTable_map_entry);
    entry.count = 2;
    entry.flags = android::ResTable_entry::FLAG_COMPLEX;
    entry.key.index = key_string_idx;
    entry.parent.ident = parent_ident;
    item0.value.size = sizeof(android::Res_value);
    item1.value.size = sizeof(android::Res_value);
  }
});
} // namespace

TEST(ResTable, ComputeSizes) {
  EntryAndValue simple(0, android::Res_value::TYPE_DIMENSION, 1000);
  EXPECT_EQ(arsc::compute_entry_value_length(&simple.entry),
            sizeof(EntryAndValue));
  MapEntryAndValues complex(1, 0);
  EXPECT_EQ(arsc::compute_entry_value_length(&complex.entry),
            sizeof(MapEntryAndValues));
}

namespace {
// Data for a simple arsc file that many tests can get written against.
EntryAndValue e0(0, android::Res_value::TYPE_DIMENSION, 1000);
EntryAndValue e0_land(0, android::Res_value::TYPE_DIMENSION, 1001);
EntryAndValue e1(1, android::Res_value::TYPE_DIMENSION, 2000);
EntryAndValue e2(2, android::Res_value::TYPE_REFERENCE, 0x7f010001);
EntryAndValue id_0(0, android::Res_value::TYPE_INT_BOOLEAN, 0);
EntryAndValue id_1(1, android::Res_value::TYPE_INT_BOOLEAN, 0);
EntryAndValue id_2(2, android::Res_value::TYPE_INT_BOOLEAN, 0);
MapEntryAndValues style(3, 0);

// The package that all tests to follow will be in
android::ResTable_package package_header{.id = 0x7f,
                                         .name = {'f', 'o', 'o', '\0'}};
// Create a default ResTable_config
android::ResTable_config default_config = {
    .size = sizeof(android::ResTable_config)};
// Create a landscape config
android::ResTable_config land_config = {
    .size = sizeof(android::ResTable_config),
    .orientation = android::ResTable_config::ORIENTATION_LAND};
// And a xxhdpi config
android::ResTable_config xxhdpi_config = {
    .size = sizeof(android::ResTable_config),
    .density = android::ResTable_config::DENSITY_XXHIGH};

void build_arsc_file_and_validate(
    const std::function<void(const std::string& temp_dir,
                             const std::string& arsc_path)>& callback) {
  auto pool_flags = android::ResStringPool_header::UTF8_FLAG;
  auto global_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);

  auto key_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  constexpr uint16_t ENTRY_COUNT = 4;
  const char* entry_names[ENTRY_COUNT] = {"first", "second", "third", "fourth"};
  for (uint16_t i = 0; i < ENTRY_COUNT; i++) {
    key_strings_builder->add_string(entry_names[i], strlen(entry_names[i]));
  }

  auto type_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  constexpr uint8_t TYPE_COUNT = 2;
  const char* type_names[2] = {"dimen", "style"};
  for (uint16_t i = 0; i < TYPE_COUNT; i++) {
    type_strings_builder->add_string(type_names[i], strlen(type_names[i]));
  }

  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(key_strings_builder);
  package_builder->set_type_strings(type_strings_builder);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(global_strings_builder);
  table_builder->add_package(package_builder);

  // dimen
  std::vector<android::ResTable_config*> dimen_configs = {&default_config,
                                                          &land_config};
  // First res ID has entries in two different configs (this flag denotes that).
  // Subsequent two entries only have default config entries (hence zero).
  std::vector<uint32_t> dimen_flags = {
      android::ResTable_config::CONFIG_ORIENTATION, 0, 0};
  auto dimen_type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 1, dimen_configs, dimen_flags);
  package_builder->add_type(dimen_type_definer);

  dimen_type_definer->add(&default_config,
                          {(uint8_t*)&e0, sizeof(EntryAndValue)});
  dimen_type_definer->add(&land_config,
                          {(uint8_t*)&e0_land, sizeof(EntryAndValue)});
  dimen_type_definer->add(&default_config,
                          {(uint8_t*)&e1, sizeof(EntryAndValue)});
  dimen_type_definer->add_empty(&land_config);
  dimen_type_definer->add(&default_config,
                          {(uint8_t*)&e2, sizeof(EntryAndValue)});
  dimen_type_definer->add_empty(&land_config);

  // style
  std::vector<android::ResTable_config*> style_configs = {&xxhdpi_config};
  std::vector<uint32_t> style_flags = {
      android::ResTable_config::CONFIG_DENSITY};
  auto style_type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 2, style_configs, style_flags);
  package_builder->add_type(style_type_definer);

  style.item0.name.ident = 0x01010098; // android:textColor
  style.item0.value.dataType = android::Res_value::TYPE_INT_COLOR_RGB8;
  style.item0.value.data = 0xFF0000FF;

  style.item1.name.ident = 0x010100d4; // android:background
  style.item1.value.dataType = android::Res_value::TYPE_INT_COLOR_RGB8;
  style.item1.value.data = 0xFF00FF00;

  style_type_definer->add(&xxhdpi_config,
                          {(uint8_t*)&style, sizeof(MapEntryAndValues)});

  // Write to a file, give the callback the temp dir and file to validate
  // against.
  android::Vector<char> out;
  table_builder->serialize(&out);

  auto tmp_dir = redex::make_tmp_dir("ResTable_BuildNewTable%%%%%%%%");
  auto dest_file_path = tmp_dir.path + "/resources.arsc";
  std::cerr << "Writing new table to " << dest_file_path.c_str() << std::endl;
  write_to_file(dest_file_path, out);
  callback(tmp_dir.path, dest_file_path);
}

void delete_resources(const std::string& arsc_file_path,
                      const std::vector<uint32_t>& ids_to_delete) {
  ResourcesArscFile arsc_file(arsc_file_path);
  // Should delete all of the style entries and omit that typeSpec and
  // type entirely during serialization.
  for (const auto& id : ids_to_delete) {
    arsc_file.delete_resource(id);
  }
  arsc_file.serialize();
  // We actually have to reload the table, since all modifications are
  // meant to be written directly to disk afterwards.
  ResourcesArscFile reloaded_file(arsc_file_path);
  reloaded_file.remove_unreferenced_strings();
}

UNUSED int32_t load_global_strings(const RedexMappedFile& arsc_file,
                                   android::ResStringPool* pool) {
  apk::TableParser parser;
  parser.visit((void*)arsc_file.const_data(), arsc_file.size());
  auto pool_header = parser.m_global_pool_header;
  return pool->setTo(pool_header, pool_header->header.size);
}

int32_t load_key_strings(const RedexMappedFile& arsc_file,
                         android::ResStringPool* pool) {
  apk::TableParser parser;
  parser.visit((void*)arsc_file.const_data(), arsc_file.size());
  // Only 1 package in our test arsc file.
  auto pool_header = parser.m_package_key_string_headers.begin()->second;
  return pool->setTo(pool_header, pool_header->header.size);
}

int32_t load_type_strings(const RedexMappedFile& arsc_file,
                          android::ResStringPool* pool) {
  apk::TableParser parser;
  parser.visit((void*)arsc_file.const_data(), arsc_file.size());
  // Only 1 package in our test arsc file.
  auto pool_header = parser.m_package_type_string_headers.begin()->second;
  return pool->setTo(pool_header, pool_header->header.size);
}

std::vector<arsc::TypeInfo> load_types(const RedexMappedFile& arsc_file) {
  apk::TableParser parser;
  parser.visit((void*)arsc_file.const_data(), arsc_file.size());
  return parser.m_package_types.begin()->second;
}

// Assert values in the table match the expected "EntryAndValue"
#define ASSERT_ENTRY_VALUES(table, config_str, entry_str, expected) \
  ({                                                                \
    uint32_t __id = (table).get_identifier(entry_str);              \
    android::Res_value __actual_value =                             \
        (table).get_simple_value((config_str), __id);               \
    EXPECT_EQ((expected).value.size, __actual_value.size);          \
    EXPECT_EQ((expected).value.dataType, __actual_value.dataType);  \
    EXPECT_EQ((expected).value.data, __actual_value.data);          \
  })
// Assert values in the table match the two items expecrted in the
// "MapEntryAndValues"
#define ASSERT_MAP_ENTRY_VALUES(table, config_str, entry_str, expected) \
  ({                                                                    \
    uint32_t __id = (table).get_identifier(entry_str);                  \
    std::vector __vec = (table).get_complex_values((config_str), __id); \
    EXPECT_EQ(__vec.size(), 2);                                         \
    auto& __vec0 = __vec[0];                                            \
    auto& __vec1 = __vec[1];                                            \
    EXPECT_EQ(__vec0.key, (expected).item0.name.ident);                 \
    EXPECT_STREQ(__vec0.kind.c_str(),                                   \
                 value_to_type_string((expected).item0.value).c_str()); \
    EXPECT_EQ(__vec0.data, (expected).item0.value.data);                \
    EXPECT_EQ(__vec1.key, (expected).item1.name.ident);                 \
    EXPECT_STREQ(__vec1.kind.c_str(),                                   \
                 value_to_type_string((expected).item1.value).c_str()); \
    EXPECT_EQ(__vec1.data, (expected).item1.value.data);                \
  })
// As above, but look up via resource ID instead of string
#define ASSERT_ID_VALUES(table, config_str, id, expected)          \
  ({                                                               \
    android::Res_value __actual_value =                            \
        (table).get_simple_value((config_str), (id));              \
    EXPECT_EQ((expected).value.size, __actual_value.size);         \
    EXPECT_EQ((expected).value.dataType, __actual_value.dataType); \
    EXPECT_EQ((expected).value.data, __actual_value.data);         \
  })
} // namespace

TEST(ResTable, BuildNewTable) {
  build_arsc_file_and_validate([&](const std::string& /* unused */,
                                   const std::string& arsc_path) {
    // Now, use unforked AOSP APIs to read out the data to make sure it
    // matches the stuff we put in.
    auto table_dump = aapt_dump_and_parse(arsc_path);
    // 0x7f010000
    ASSERT_ENTRY_VALUES(table_dump, "default", "foo:dimen/first", e0);
    // 0x7f010001
    ASSERT_ENTRY_VALUES(table_dump, "default", "foo:dimen/second", e1);
    // 0x7f010002
    ASSERT_ENTRY_VALUES(table_dump, "default", "foo:dimen/third", e2);
    // Rotate to landscape should get different values for entry 0x7f010000
    ASSERT_ENTRY_VALUES(table_dump, "land", "foo:dimen/first", e0_land);
    // Separate validation for plurals, styles, etc.
    ASSERT_MAP_ENTRY_VALUES(table_dump, "xxhdpi", "foo:style/fourth", style);
  });
}

TEST(ResTable, DeleteAllEntriesInType) {
  build_arsc_file_and_validate(
      [&](const std::string& /* unused */, const std::string& arsc_path) {
        // Delete everything in the style type.
        delete_resources(arsc_path, {0x7f020000});
        // Make sure the table is still valid after deletion.
        auto table_dump = aapt_dump_and_parse(arsc_path);
        // 0x7f010000
        ASSERT_ENTRY_VALUES(table_dump, "default", "foo:dimen/first", e0);
        // 0x7f010001
        ASSERT_ENTRY_VALUES(table_dump, "default", "foo:dimen/third", e2);
        // Rotate to landscape should get different values for entry 0x7f010000
        ASSERT_ENTRY_VALUES(table_dump, "land", "foo:dimen/first", e0_land);

        // This one should have been deleted!!
        EXPECT_EQ(table_dump.get_identifier("foo:style/fourth"), 0)
            << "Style was not properly deleted!";

        // Check the validity of the string pools and ensure data is getting
        // fully cleaned up.
        auto built_arsc_file = RedexMappedFile::open(arsc_path);
        {
          // Make sure the key for "fourth" got deleted.
          android::ResStringPool pool;
          EXPECT_EQ(load_key_strings(built_arsc_file, &pool), 0);
          EXPECT_EQ(pool.size(), 3);
          std::unordered_set<std::string> string_values;
          for (size_t i = 0; i < pool.size(); i++) {
            string_values.emplace(apk::get_string_from_pool(pool, i));
          }
          EXPECT_EQ(string_values.count("fourth"), 0);
          EXPECT_EQ(string_values.count("first"), 1);
          EXPECT_EQ(string_values.count("second"), 1);
          EXPECT_EQ(string_values.count("third"), 1);
        }
        {
          // We do not yet delete the type names, for now just validate that
          // dimen is still here.
          android::ResStringPool pool;
          EXPECT_EQ(load_type_strings(built_arsc_file, &pool), 0);
          std::unordered_set<std::string> string_values;
          for (size_t i = 0; i < pool.size(); i++) {
            string_values.emplace(apk::get_string_from_pool(pool, i));
          }
          EXPECT_EQ(string_values.count("dimen"), 1);
        }

        // Ensure that we have only 1 ResTable_typeSpec, but two configs within.
        auto type_infos = load_types(built_arsc_file);
        EXPECT_EQ(type_infos.size(), 1) << "ResTable_typeSpec not cleaned up!";
        EXPECT_EQ(type_infos.at(0).configs.size(), 2);
      });
}

TEST(ResTable, DeleteAllLandscapeEntries) {
  build_arsc_file_and_validate([&](const std::string& /* unused */,
                                   const std::string& arsc_path) {
    // Delete the lone dimen entry that has a landscape override.
    delete_resources(arsc_path, {0x7f010000});
    // Make sure the table is still valid after deletion.
    auto table_dump = aapt_dump_and_parse(arsc_path);
    // This one should have been deleted!!
    EXPECT_EQ(table_dump.get_identifier("foo:dimen/first"), 0)
        << "Entry was not properly deleted!";

    ASSERT_ENTRY_VALUES(table_dump, "default", "foo:dimen/second", e1);
    ASSERT_ENTRY_VALUES(table_dump, "default", "foo:dimen/third", e2);
    ASSERT_MAP_ENTRY_VALUES(table_dump, "xxhdpi", "foo:style/fourth", style);

    // Deleting the resource should ensure that no ResTable_type for
    // landscape config was emitted. We should still have two
    // ResTable_typeSpec structs though.
    auto built_arsc_file = RedexMappedFile::open(arsc_path);
    auto type_infos = load_types(built_arsc_file);
    EXPECT_EQ(type_infos.size(), 2);
    EXPECT_EQ(type_infos.at(0).configs.size(), 1)
        << "ResTable_type not cleaned up!";
    EXPECT_EQ(type_infos.at(1).configs.size(), 1);
  });
}

TEST(ResTable, SerializeTypeWithAllEmpty) {
  auto pool_flags = android::ResStringPool_header::UTF8_FLAG;
  auto global_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  auto key_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  auto type_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  std::string type_name("dimen");
  type_strings_builder->add_string(type_name.c_str(), type_name.size());

  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(key_strings_builder);
  package_builder->set_type_strings(type_strings_builder);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(global_strings_builder);
  table_builder->add_package(package_builder);

  // Make a dimen type that is entirely full of empty things
  std::vector<android::ResTable_config*> dimen_configs = {&default_config};
  std::vector<uint32_t> dimen_flags = {0, 0, 0};
  auto dimen_type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 1, dimen_configs, dimen_flags);
  package_builder->add_type(dimen_type_definer);
  dimen_type_definer->add_empty(&default_config);
  dimen_type_definer->add_empty(&default_config);
  dimen_type_definer->add_empty(&default_config);

  // Write to a file, which should be omitting the ResTable_typeSpec and
  // ResTable_type!
  android::Vector<char> out;
  table_builder->serialize(&out);

  auto tmp_dir =
      redex::make_tmp_dir("ResTable_SerializeTypeWithAllEmpty%%%%%%%%");
  auto dest_file_path = tmp_dir.path + "/resources.arsc";
  write_to_file(dest_file_path, out);

  auto build_arsc_file = RedexMappedFile::open(dest_file_path);
  apk::TableParser parser;
  parser.visit((void*)build_arsc_file.const_data(), build_arsc_file.size());
  // Make sure there are no type structures (actual assert is a little wishy
  // washy here cause representing empty data could sensibly be done in
  // different ways).
  EXPECT_TRUE(parser.m_package_types.empty() ||
              parser.m_package_types.begin()->second.empty())
      << "Should not emit type headers for empty data";

  // Final check, make sure Android APIs can parse the table with no types (this
  // will throw with non-zero exit code).
  aapt_dump_and_parse(dest_file_path);
}

namespace {

void build_table_with_ids(const std::string& dest_file_path,
                          bool canonical_entries) {
  auto pool_flags = android::ResStringPool_header::UTF8_FLAG;
  auto global_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  auto key_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  std::vector<std::string> key_strings = {"foo", "name_removed", "bar"};
  for (const auto& s : key_strings) {
    key_strings_builder->add_string(s.c_str(), s.size());
  }
  auto type_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  std::string type_name("id");
  type_strings_builder->add_string(type_name.c_str(), type_name.size());

  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(key_strings_builder);
  package_builder->set_type_strings(type_strings_builder);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(global_strings_builder);
  table_builder->add_package(package_builder);

  // Make a dimen type that is entirely full of empty things
  std::vector<android::ResTable_config*> id_configs = {&default_config};
  std::vector<uint32_t> flags = {0, 0, 0, 0, 0, 0};
  auto type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 1, id_configs, flags, canonical_entries);
  package_builder->add_type(type_definer);
  type_definer->add(&default_config, {(uint8_t*)&id_0, sizeof(EntryAndValue)});
  // When canonical_entries is true, following three items will generate three
  // offsets that point to just a single copy of the 16 entry/value bytes.
  type_definer->add(&default_config, {(uint8_t*)&id_1, sizeof(EntryAndValue)});
  type_definer->add(&default_config, {(uint8_t*)&id_1, sizeof(EntryAndValue)});
  type_definer->add(&default_config, {(uint8_t*)&id_1, sizeof(EntryAndValue)});
  // When canonical_entries is true, following two items will generate two
  // offsets that point to just a single copy of the 16 entry/value bytes.
  type_definer->add(&default_config, {(uint8_t*)&id_2, sizeof(EntryAndValue)});
  type_definer->add(&default_config, {(uint8_t*)&id_2, sizeof(EntryAndValue)});

  android::Vector<char> out;
  table_builder->serialize(&out);
  write_to_file(dest_file_path, out);
}

} // namespace

TEST(ResTable, ValueEquality) {
  auto pool_flags = android::ResStringPool_header::UTF8_FLAG;
  auto global_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  auto key_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  auto type_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  key_strings_builder->add_string("foo");
  type_strings_builder->add_string("dimen");

  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(key_strings_builder);
  package_builder->set_type_strings(type_strings_builder);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(global_strings_builder);
  table_builder->add_package(package_builder);

  std::vector<android::ResTable_config*> dimen_configs = {
      &default_config, &land_config, &xxhdpi_config};
  std::vector<uint32_t> dimen_flags = {0, 0, 0, 0, 0};
  auto type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 1, dimen_configs, dimen_flags);
  package_builder->add_type(type_definer);

  EntryAndValue a(0, android::Res_value::TYPE_INT_COLOR_RGB8, 123456);
  EntryAndValue b(0, android::Res_value::TYPE_INT_COLOR_ARGB8, 123456);

  EntryAndValue x(0, android::Res_value::TYPE_DIMENSION, 100);
  EntryAndValue y(0, android::Res_value::TYPE_FRACTION, 200);
  EntryAndValue z(0, android::Res_value::TYPE_INT_DEC, 666);

  // 0x7f010000
  type_definer->add_empty(&default_config);
  type_definer->add(&land_config, {(uint8_t*)&a, sizeof(EntryAndValue)});
  type_definer->add(&xxhdpi_config, {(uint8_t*)&b, sizeof(EntryAndValue)});
  // 0x7f010001, make it the reverse of the above (not equal)
  type_definer->add_empty(&default_config);
  type_definer->add(&land_config, {(uint8_t*)&b, sizeof(EntryAndValue)});
  type_definer->add(&xxhdpi_config, {(uint8_t*)&a, sizeof(EntryAndValue)});
  // 0x7f010002
  type_definer->add(&default_config, {(uint8_t*)&x, sizeof(EntryAndValue)});
  type_definer->add(&land_config, {(uint8_t*)&y, sizeof(EntryAndValue)});
  type_definer->add(&xxhdpi_config, {(uint8_t*)&z, sizeof(EntryAndValue)});
  // 0x7f010003
  type_definer->add_empty(&default_config);
  type_definer->add(&land_config, {(uint8_t*)&b, sizeof(EntryAndValue)});
  type_definer->add_empty(&xxhdpi_config);
  // 0x7f010004, should be equal to 0x7f010002
  type_definer->add(&default_config, {(uint8_t*)&x, sizeof(EntryAndValue)});
  type_definer->add(&land_config, {(uint8_t*)&y, sizeof(EntryAndValue)});
  type_definer->add(&xxhdpi_config, {(uint8_t*)&z, sizeof(EntryAndValue)});

  android::Vector<char> out;
  table_builder->serialize(&out);

  auto tmp_dir = redex::make_tmp_dir("ResTable_ValueEquality%%%%%%%%");
  auto dest_file_path = tmp_dir.path + "/resources.arsc";
  write_to_file(dest_file_path, out);
  ResourcesArscFile arsc_file(dest_file_path);

  // Obvious sanity checks
  EXPECT_TRUE(arsc_file.resource_value_identical(0x7f010000, 0x7f010000));
  EXPECT_TRUE(arsc_file.resource_value_identical(0x7f010001, 0x7f010001));
  EXPECT_TRUE(arsc_file.resource_value_identical(0x7f010002, 0x7f010002));
  EXPECT_TRUE(arsc_file.resource_value_identical(0x7f010003, 0x7f010003));
  EXPECT_TRUE(arsc_file.resource_value_identical(0x7f010004, 0x7f010004));

  // Real checks
  EXPECT_TRUE(arsc_file.resource_value_identical(0x7f010002, 0x7f010004));

  EXPECT_FALSE(arsc_file.resource_value_identical(0x7f010000, 0x7f010001));
  EXPECT_FALSE(arsc_file.resource_value_identical(0x7f010000, 0x7f010002));
  EXPECT_FALSE(arsc_file.resource_value_identical(0x7f010001, 0x7f010002));
  EXPECT_FALSE(arsc_file.resource_value_identical(0x7f010002, 0x7f010003));
}

TEST(ResTable, CanonicalEntryData) {
  auto do_validation = [&](const std::string& file_path,
                           uint32_t type_expected_size) {
    auto table_dump = aapt_dump_and_parse(file_path);
    ASSERT_ID_VALUES(table_dump, "default", 0x7f010000, id_0);
    ASSERT_ID_VALUES(table_dump, "default", 0x7f010001, id_1);
    ASSERT_ID_VALUES(table_dump, "default", 0x7f010002, id_1);
    ASSERT_ID_VALUES(table_dump, "default", 0x7f010003, id_1);
    ASSERT_ID_VALUES(table_dump, "default", 0x7f010004, id_2);
    ASSERT_ID_VALUES(table_dump, "default", 0x7f010005, id_2);

    // Assert the size of the ResTable_type for the id table
    auto file = RedexMappedFile::open(file_path);
    apk::TableParser parser;
    parser.visit((void*)file.const_data(), file.size());
    auto type_info = parser.m_package_types.begin()->second.at(0);
    EXPECT_EQ(type_info.configs.at(0)->header.size, type_expected_size)
        << "ResTable_type was not expected size!";
  };

  uint32_t num_entries = 6;
  uint32_t expected_size_no_canon = sizeof(android::ResTable_type) +
                                    num_entries * sizeof(uint32_t) +
                                    num_entries * sizeof(EntryAndValue);
  // Three of these things are duplicated, but the offsets will remain.
  uint32_t expected_size_canon =
      expected_size_no_canon - 3 * sizeof(EntryAndValue);

  auto tmp_dir = redex::make_tmp_dir("ResTable_CanonicalEntryData%%%%%%%%");

  auto no_canonical_path = tmp_dir.path + "/no_canon.arsc";
  build_table_with_ids(no_canonical_path, false);
  do_validation(no_canonical_path, expected_size_no_canon);

  auto canonical_path = tmp_dir.path + "/canon.arsc";
  build_table_with_ids(canonical_path, true);
  do_validation(canonical_path, expected_size_canon);

  // Make sure the Projector also emits the data properly in canonical form. Do
  // this by taking the non-canonical table, as prepared by the Definer, and
  // copy it all into a new builder using the Projector with the
  // "enable_canonical_entries" flag flipped to true.
  auto no_canon_file = RedexMappedFile::open(no_canonical_path);
  apk::TableParser parsed_table;
  parsed_table.visit((void*)no_canon_file.const_data(), no_canon_file.size());
  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(
      parsed_table.m_package_key_string_headers.begin()->second);
  package_builder->set_type_strings(
      parsed_table.m_package_type_string_headers.begin()->second);

  auto& id_type = parsed_table.m_package_types.begin()->second.at(0);
  auto type_projector = std::make_shared<arsc::ResTableTypeProjector>(
      package_header.id, id_type.spec, id_type.configs, true);
  package_builder->add_type(type_projector);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(parsed_table.m_global_pool_header);
  table_builder->add_package(package_builder);
  android::Vector<char> out;
  table_builder->serialize(&out);

  auto projector_canon_path = tmp_dir.path + "/projector_canon.arsc";
  write_to_file(projector_canon_path, out);
  do_validation(projector_canon_path, expected_size_canon);
}

TEST(ResTable, GetStringsByName) {
  // Make the strangest hypothetical table that could exist (string with values
  // in multiple configs, references with cycles, etc).
  auto pool_flags = android::ResStringPool_header::UTF8_FLAG;
  auto global_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  global_strings_builder->add_string("a");
  global_strings_builder->add_string("b");
  global_strings_builder->add_string("c");
  global_strings_builder->add_string("d");
  global_strings_builder->add_string("e");
  auto key_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  key_strings_builder->add_string("first");
  key_strings_builder->add_string("second");
  key_strings_builder->add_string("third");
  key_strings_builder->add_string("fourth");
  auto type_strings_builder =
      std::make_shared<arsc::ResStringPoolBuilder>(pool_flags);
  type_strings_builder->add_string("string");

  auto package_builder =
      std::make_shared<arsc::ResPackageBuilder>(&package_header);
  package_builder->set_key_strings(key_strings_builder);
  package_builder->set_type_strings(type_strings_builder);

  auto table_builder = std::make_shared<arsc::ResTableBuilder>();
  table_builder->set_global_strings(global_strings_builder);
  table_builder->add_package(package_builder);

  std::vector<android::ResTable_config*> string_configs = {&default_config,
                                                           &land_config};
  std::vector<uint32_t> string_flags = {
      0, android::ResTable_config::CONFIG_ORIENTATION,
      android::ResTable_config::CONFIG_ORIENTATION,
      android::ResTable_config::CONFIG_ORIENTATION};
  auto type_definer = std::make_shared<arsc::ResTableTypeDefiner>(
      package_header.id, 1, string_configs, string_flags);
  package_builder->add_type(type_definer);

  EntryAndValue first(0, android::Res_value::TYPE_STRING, 0);
  type_definer->add(&default_config, {(uint8_t*)&first, sizeof(EntryAndValue)});
  type_definer->add_empty(&land_config);

  EntryAndValue second(1, android::Res_value::TYPE_STRING, 1);
  EntryAndValue second_land(1, android::Res_value::TYPE_STRING, 2);
  type_definer->add(&default_config,
                    {(uint8_t*)&second, sizeof(EntryAndValue)});
  type_definer->add(&land_config,
                    {(uint8_t*)&second_land, sizeof(EntryAndValue)});

  // These next two entries are diabolical as some of their entries will be
  // cyclic.
  EntryAndValue third(2, android::Res_value::TYPE_STRING, 3);
  EntryAndValue third_land(2, android::Res_value::TYPE_REFERENCE, 0x7f010003);
  type_definer->add(&default_config, {(uint8_t*)&third, sizeof(EntryAndValue)});
  type_definer->add(&land_config,
                    {(uint8_t*)&third_land, sizeof(EntryAndValue)});

  EntryAndValue fourth(3, android::Res_value::TYPE_REFERENCE, 0x7f010002);
  EntryAndValue fourth_land(3, android::Res_value::TYPE_STRING, 4);
  type_definer->add(&default_config,
                    {(uint8_t*)&fourth, sizeof(EntryAndValue)});
  type_definer->add(&land_config,
                    {(uint8_t*)&fourth_land, sizeof(EntryAndValue)});

  android::Vector<char> out;
  table_builder->serialize(&out);

  auto tmp_dir = redex::make_tmp_dir("ResTable_GetStringsByName%%%%%%%%");
  auto arsc_path = tmp_dir.path + "/resources.arsc";
  write_to_file(arsc_path, out);

  ResourcesArscFile arsc_file(arsc_path);
  auto vec = arsc_file.get_resource_strings_by_name("first");
  EXPECT_EQ(vec.size(), 1);
  EXPECT_STREQ(vec[0].c_str(), "a");
  vec = arsc_file.get_resource_strings_by_name("second");
  EXPECT_EQ(vec.size(), 2);
  EXPECT_STREQ(vec[0].c_str(), "b");
  EXPECT_STREQ(vec[1].c_str(), "c");
  vec = arsc_file.get_resource_strings_by_name("third");
  EXPECT_EQ(vec.size(), 2);
  EXPECT_STREQ(vec[0].c_str(), "d");
  EXPECT_STREQ(vec[1].c_str(), "e");
  vec = arsc_file.get_resource_strings_by_name("blah");
  EXPECT_EQ(vec.size(), 0);
}
