[{"title":"Office Hours","type":0,"sectionRef":"#","url":"/blog/office-hours/","content":"!!! Redex Public Office Hour Coming on Wed. 10/26/2022 @2PM PST !!! Zoom Meeting id: 921 3454 5091; passcode: 177943 Please dial in to chat! We would love to learn how do you use Redex, what challenges are you facing, and how can we better help. We would like keep the 1st office hour to be more high level. If you have very specific questions, like how to build Redex, Github issue is still the best way to resolve it.","keywords":"","version":null},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/getting_started/","content":"Getting Started Hi, Redex is an Android bytecode optimizer and stuff.","keywords":"","version":"Next"},{"title":"Using ProGuard Rules with Redex","type":0,"sectionRef":"#","url":"/docs/examples/proguard/","content":"","keywords":"","version":"Next"},{"title":"The Need To Control Shrinking​","type":1,"pageTitle":"Using ProGuard Rules with Redex","url":"/docs/examples/proguard/#the-need-to-control-shrinking","content":" One of the optimizations that Redex performs is to remove interfaces that have only one implementation. However, when there is a use of that interface through reflection or constructs like instanceof then this is an unsafe removal which should be prohibited by using a ProGuard rule.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Using ProGuard Rules with Redex","url":"/docs/examples/proguard/#example","content":" Consider the following interface:  package com.facebook.redex.examples.proguardexample; public interface Greek { int doubleWombat(); }   which only has one use:  package com.facebook.redex.examples.proguardexample; public class Alpha implements Greek { private int wombat; public Alpha () { wombat = 21; } public int doubleWombat() { return 2 * wombat; } }   and is instantiated in a main activity as follows:  package com.facebook.redex.examples.proguardexample; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView textView = (TextView) findViewById(R.id.message); Alpha alphaObject = new Alpha(); int ltuae = alphaObject.doubleWombat(); textView.setText(&quot;The answer is &quot; + ltuae + &quot;\\n&quot;); try { Class&lt;?&gt; greek = Class.forName(&quot;com.facebook.redex.examples.proguardexample.Greek&quot;); if (greek.isInstance(alphaObject)) { textView.append(&quot;Alpha is an instance of Greek&quot;); } else { textView.append(&quot;Alpha is not an instance of Greek&quot;); } } catch (ClassNotFoundException e) { textView.append(&quot;ERROR: Greek interface not found&quot;); } } }   When you make a release build of this application and then process it with Redex you will get a crash because the Greek class will be removed because it only has a single implementation, but Redex did not notice that Greek is used as part of an instanceof check (or there could have been some use of reflection that mentioned the Greek class). Running the app gives the following output on the display of the device:    You can instruct Redex to prevent a class or interface from begin deleted by providing a ProGuard rule. In this case we want to ensure the Greek interface is not deleted:  -keep interface com.facebook.redex.examples.proguardexample.Greek   When you run Redex you can specify a single ProGuard file containing simple keep rules for classes and interfaces. For example:  $ redex -o myfasterapp.apk myapp.apk -P proguard-rules.pro --sign -s ~/.android/debug.keystore -p android   Now when you run the post-Redex APK you will notice that the Greek class has not been stripped away:    ","version":"Next","tagName":"h2"},{"title":"Limitations​","type":1,"pageTitle":"Using ProGuard Rules with Redex","url":"/docs/examples/proguard/#limitations","content":" Right now we support only simple keep annotations for classes and interfaces. Shortly we will provide support a richer subset of the ProGuard configuration language.  ","version":"Next","tagName":"h2"},{"title":"Source for Example​","type":1,"pageTitle":"Using ProGuard Rules with Redex","url":"/docs/examples/proguard/#source-for-example","content":" The source code for this example can be found in this directory. ","version":"Next","tagName":"h2"},{"title":"A Simple Example","type":0,"sectionRef":"#","url":"/docs/getting_started/configuring/","content":"ReDex can be configured to run different optimizations or to alter the behavior of existing optimizations. While this isn't always necessary, it's helpful to be able to tweak settings to get the best results. A Simple Example A starting point for configuration is to use a configuration similar to the default config that's baked in to the redex binary. You can find this config in config/default.config. This is what it looks like: { &quot;redex&quot; : { &quot;passes&quot; : [ &quot;ReBindRefsPass&quot;, &quot;BridgeSynthInlinePass&quot;, &quot;FinalInlinePassV2&quot;, &quot;DelSuperPass&quot;, &quot;SingleImplPass&quot;, &quot;MethodInlinePass&quot;, &quot;StaticReloPassV2&quot;, &quot;RemoveUnreachablePass&quot;, &quot;ShortenSrcStringsPass&quot;, &quot;RegAllocPass&quot; ] } } Name this file default.config, and invoke redex with it: % redex.py -c default.config -o tmp/output.apk input.apk This will do... exactly what redex does without the config. Not so exciting, is it? Let's move on to something more advanced. Selecting Optimization Passes Changing the set of optimizations ReDex runs is easy; just add (or remove) the pass name from the redex.passes list. For example, let's say you want to remove the ShortenSrcStrings optimization while you're debugging something. Just use this config: { &quot;redex&quot; : { &quot;passes&quot; : [ &quot;ReBindRefsPass&quot;, &quot;BridgeSynthInlinePass&quot;, &quot;FinalInlinePassV2&quot;, &quot;DelSuperPass&quot;, &quot;SingleImplPass&quot;, &quot;MethodInlinePass&quot;, &quot;RemoveUnreachablePass&quot;, &quot;RegAllocPass&quot; ] } } Configuring optimization behavior Each optimization pass has some configurable parameters that are specific to that pass. These are often blocklists (or allowlists) indicating what code the optimization should leave alone (for blocklists) or what code should be optimized (for allowlists). A simple example is ShortenSrcStrings. This pass removes filenames indicating what source code produced each class. It's a waste to ship those source strings to production, but it's useful to be able to map the shortened names back to the original names (e.g., for solving user bug reports). You can tell ShortenSrcStrings to produce this map by adding a config entry: &quot;redex&quot; : { &quot;passes&quot; : [ ShortenSrcStringsPass, &quot;RegAllocPass&quot; ] }, &quot;ShortenSrcStringsPass&quot; : { &quot;filename_mappings&quot; : &quot;/tmp/filename_mappings.txt&quot; } Options for each pass are documented with that pass. Global options redex.passesType: array of strings A list of passes to be run in the specified order. coldstart_classesType: string Path to a file containing a list of class names in the order they are used for cold start. Example format: com/foo/Bar.class com/foo/Baz.class ... com/foo/Quux.class proguard_mapType: string Path to a file containing ProGuard's mapping of unobfuscated class/field/method names to obfuscated names. This option is useful if you are running ReDex after ProGuard, so that ReDex will properly understand obfuscated names. Complete configuration To see the (almost) complete list of configuration parameters, run redex-all --reflect-config (Note that you run redex-all here, not the redex.py wrapper!) This emits a JSON document detailing parameters, their types, defaults and possibly documentation.","keywords":"","version":"Next"},{"title":"Redex Synth Pass Example","type":0,"sectionRef":"#","url":"/docs/examples/synth/","content":"","keywords":"","version":"Next"},{"title":"Removing synthetic methods for accessing static fields​","type":1,"pageTitle":"Redex Synth Pass Example","url":"/docs/examples/synth/#removing-synthetic-methods-for-accessing-static-fields","content":" This directory contains an Android Studio 1.5 project that illustrates how a wrapper synthetic method is removed by Redex. The contrived example is a simple Android application which makes use of this class:  package com.facebook.redex.examples.synth; public class Alpha { private static int alpha; public Alpha(int initialValue) { alpha = initialValue; } public class Beta { public int doubleAlpha() { return 2 * alpha; } } }   The key thing to note here is that there is an inner class Beta which has a method doubleAlpha which accesses a private static field alpha of its outer class Alpha. A dump of the Dex bytecode for the Alpha class confirms that the alpha field is private and static.   Static fields - #0 : (in Lcom/facebook/redex/examples/synth/Alpha;) name : 'alpha' type : 'I' access : 0x000a (PRIVATE STATIC)   Java compilers will implement accesses] to this field from inner classes by generating a synthetic getter method to allow the inner class to access the private field of the outer class. We can see the automatically generated synthetic method access$000if we examine the Dex bytecode for the Alpha class:  Class #597 - Class descriptor : 'Lcom/facebook/redex/examples/synth/Alpha;' ... #1 : (in Lcom/facebook/redex/examples/synth/Alpha;) name : 'access$000' type : '()I' access : 0x1008 (STATIC SYNTHETIC) code - registers : 1 ins : 0 outs : 0 insns size : 3 16-bit code units 065f14: |[065f14] com.facebook.redex.examples.synth.Alpha.access$000:()I 065f24: 6000 070b |0000: sget v0, Lcom/facebook/redex/examples/synth/Alpha;.alpha:I // field@0b07 065f28: 0f00 |0002: return v0   This generated synthetic method can be accessed by the inner class which keeps the JVM happy. All it does is to read the state field value using an sget instruction and return the read value. This synthetic wrapper is used in the implementation of doubleAlpha:   Virtual methods - #0 : (in Lcom/facebook/redex/examples/synth/Alpha$Beta;) name : 'doubleAlpha' ... 065ed8: |[065ed8] com.facebook.redex.examples.synth.Alpha.Beta.doubleAlpha:()I 065ee8: 7100 1118 0000 |0000: invoke-static {}, Lcom/facebook/redex/examples/synth/Alpha;.access$000:()I // method@1811 065eee: 0a00 |0003: move-result v0 065ef0: da00 0002 |0004: mul-int/lit8 v0, v0, #int 2 // #02 065ef4: 0f00 |0006: return v0   For the doubleAlpha method in the inner class Beta to access the private static field of the enclosing class an invoke-static call is made to the synthetic wrapper method access$000.  Here is an example of the doubleAlpha method being used from a simple Android application:  package com.facebook.redex.examples.synth; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView textView = (TextView) findViewById(R.id.message); textView.setText(&quot;Redex Synth Example\\n&quot;); Alpha a = new Alpha(12); Alpha.Beta b = a.new Beta(); textView.append(&quot;Double Alpha(12) = &quot; + b.doubleAlpha() + &quot;\\n&quot;); } }   If we examined the Dex bytecode for the call to doubleAlpha we would see something like this which shows a virtual call to the doubleAlpha method:   Direct methods - #0 : (in Lcom/facebook/redex/examples/synth/MainActivity;) name : 'onCreate' ... 065fb6: 6e10 0f18 0100 |0031: invoke-virtual {v1}, Lcom/facebook/redex/examples/synth/Alpha$Beta;.doubleAlpha:()I // method@180f ...   After running Redex the synthetic wrapper method will be removed and the code for accessing the alpha static field will be inlined into the code for the main activity:   Direct methods - #0 : (in Lcom/facebook/redex/examples/synth/MainActivity;) name : 'onCreate' ... 07f246: 6005 4d06 |0031: sget v5, Lcom/facebook/redex/examples/synth/Alpha;.alpha:I // field@064d 07f24a: da05 0502 |0033: mul-int/lit8 v5, v5, #int 2 // #02 ...   To make the access of the alpha field legal for the Dalvik VM we have mutated the access permissions for this field:   Static fields - #0 : (in Lcom/facebook/redex/examples/synth/Alpha;) name : 'alpha' type : 'I' access : 0x0009 (PUBLIC STATIC)   Similar optimizations exist for other synthetic wrapper scenarios e.g. for instance fields.  ","version":"Next","tagName":"h2"},{"title":"Example Code​","type":1,"pageTitle":"Redex Synth Pass Example","url":"/docs/examples/synth/#example-code","content":" The project in the synth-example directory can be opened with Android Studio 1.5 and contains the sample here that illustrates the removal of synthetic wrappers for static private fields.  The Makefile in this directory can be used once you have build a signed: APK (Build : Generate Signed APK...) to produce the following items:  synth-example-release-redex.apk: A Redex optimized version of the original APK.classes.dump: A dump of the Dex bytecode for the input APK synth-example-release.apk.classes-redex.dump: A dump of the Redex optimizd APK synth-example-release-redex.apk.  The environment variable ANDROID_TOOLS should be set to the location of your Android SDK tools directory.  To produce these items:  $ make clean all  ","version":"Next","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/getting_started/installation/","content":"","keywords":"","version":"Next"},{"title":"Dependencies​","type":1,"pageTitle":"Installation","url":"/docs/getting_started/installation/#dependencies","content":" We use package managers to resolve third-party library dependencies.  ","version":"Next","tagName":"h2"},{"title":"macOS​","type":1,"pageTitle":"Installation","url":"/docs/getting_started/installation/#macos","content":" You will need Xcode with command line tools installed. To get the command line tools, use:  xcode-select --install   Install dependencies using homebrew:  brew install autoconf automake libtool python3 brew install boost jsoncpp   For App Bundle support brew install protobuf is also required.  ","version":"Next","tagName":"h3"},{"title":"Ubuntu/Debian (64-bit)​","type":1,"pageTitle":"Installation","url":"/docs/getting_started/installation/#ubuntudebian-64-bit","content":" Base requirements are automake &amp; libtool, GCC &gt;= 7, Python &gt;= 3.6 and Boost &gt;= 1.71.0, as well as development versions of iberty, jemalloc, jsoncpp, lz4, lzma, and zlib. Protobuf &gt;= 3.0 is required if optimizing an App Bundle.  Ubuntu 18.04+, Debian 10(Buster)+​  The minimum supported Ubuntu version is 18.04. The minimum supported Debian version is 10.  A convenience scriptwill set up the build environment. This may include downloading Python 3.6 and Boost 1.71.0 on older OS versions.  sudo ./setup_oss_toolchain.sh   After the script, please run sudo ldconfig if it throws an error about loading shared libraries for running protoc.  ","version":"Next","tagName":"h3"},{"title":"Experimental: Windows (64-bit) with MSYS2​","type":1,"pageTitle":"Installation","url":"/docs/getting_started/installation/#experimental-windows-64-bit-with-msys2","content":" You need MSYS2 to build redex-all (only MingW-w64 is supported) and Python 3.6+ to run redex.py.  Install the build requirements in an MSYS or MingW64 shell:  pacman -Syuu &amp;&amp; pacman -Sy make mingw-w64-x86_64-boost mingw-w64-x86_64-cmake mingw-w64-x86_64-gcc mingw-w64-x86_64-jsoncpp mingw-w64-x86_64-make   If you do not use Git on Windows directly, you may install and use it under MSYS2:  pacman -S git   ","version":"Next","tagName":"h3"},{"title":"Experimental: Windows 10 (64-bit)​","type":1,"pageTitle":"Installation","url":"/docs/getting_started/installation/#experimental-windows-10-64-bit","content":" You need Visual Studio 2017. Visual Studio 2015 is also possible, but a couple of C++ compile errors need to be fixed. We use vcpkg for dependencies. Install vcpkg from their document:  cd c:\\tools git clone https://github.com/Microsoft/vcpkg.git cd vcpkg .\\bootstrap-vcpkg.bat .\\vcpkg integrate install   Install necessary libraries with x64-windows-static:  .\\vcpkg install boost --triplet x64-windows-static .\\vcpkg install zlib --triplet x64-windows-static .\\vcpkg install jsoncpp --triplet x64-windows-static .\\vcpkg install mman --triplet x64-windows-static   ","version":"Next","tagName":"h3"},{"title":"Download, Build and Install​","type":1,"pageTitle":"Installation","url":"/docs/getting_started/installation/#download-build-and-install","content":" Get ReDex from GitHub:  git clone https://github.com/facebook/redex.git cd redex   Now, build ReDex using autoconf and make.  autoreconf -ivf &amp;&amp; ./configure &amp;&amp; make sudo make install   Alternatively, to enable protobuf to support App Bundles, please use:  autoreconf -ivf &amp;&amp; ./configure --enable-protobuf make sudo make install   For protobuf installed in the default system (Homebrew) search path (e.g /usr/local/bin), --enable-protobuf is sufficient to trigger the build. Otherwise, specify the protobuf installation path for the autoconf:  autoreconf -ivf ./configure --with-protoc=/path/to/protoc --with-protolib=/path/to/protobuf_libs --with-protoheader=/path/to/protobuf_headers --enable-protobuf make sudo make install   If your build machine has lots of RAM (on the order of 2-4GB per core), using Make parallelism can speed up the build (e.g., make -j4). However, the C++ compilers are very memory hungry and this needs to be finely tuned on many systems.  ","version":"Next","tagName":"h2"},{"title":"Experimental: Windows (64-bit) with MSYS2​","type":1,"pageTitle":"Installation","url":"/docs/getting_started/installation/#experimental-windows-64-bit-with-msys2-1","content":" The MSYS2 build relies on CMake. In a MingW64 shell:  # Assumes you want to use Git under MSYS. Else skip to below. git clone https://github.com/facebook/redex.git cd redex # Assumes you are in the redex directory mkdir build-cmake cd build-cmake cmake -G &quot;MSYS Makefiles&quot; .. make   If your build machine has lots of RAM (on the order of 2-4GB per core), using Make parallelism can speed up the build (e.g., make -j4). However, the C++ compilers are very memory hungry and this needs to be finely tuned on many systems.  You may check whether the produced binary seems in a working condition:  # In the MingW64 shell: ./redex-all.exe --show-passes # Or in a standard Windows command prompt in the same directory redex-all.exe --show-passes   The output should show a large number of included passes, at the time of writing 81.  Bundling the redex-all binary with the python scripts is not supported on Windows. Manually copy the binary into the same directory as redex.py and use redex.py that way, or ensure that redex.py is called with the --redex-binary parameter:  python redex.py --redex-binary PATH_TO_BINARY [...]   ","version":"Next","tagName":"h3"},{"title":"Experimental: CMake for Mac, Linux, and Windows​","type":1,"pageTitle":"Installation","url":"/docs/getting_started/installation/#experimental-cmake-for-mac-linux-and-windows","content":" Alternatively, build using CMake. Note that the current CMakeLists.txt only implements a rule for redex-all binary. We will support installation and testing soon.  Generate build files. By default, it uses Makefile:  # Assume you are in redex directory mkdir build-cmake cd build-cmake # .. is the root source directory of Redex cmake ..   If you prefer the ninja build system:  cmake .. -G Ninja   On Windows, first, get CMAKE_TOOLCHAIN_FILE from the output of &quot;vcpkg integrate install&quot;, and then:  cmake .. -G &quot;Visual Studio 15 2017 Win64&quot; -DVCPKG_TARGET_TRIPLET=x64-windows-static -DCMAKE_TOOLCHAIN_FILE=&quot;C:/tools/vcpkg/scripts/buildsystems/vcpkg.cmake&quot;   Build redex-all:  cmake --build .   On Windows, you may build from Visual Studio. Redex.sln has been generated.  You should see a redex-all executable, and the executable should show about 45 passes.  ./redex-all --show-passes   ","version":"Next","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"Installation","url":"/docs/getting_started/installation/#test","content":" Optionally, you can run our unit test suite. We use gtest, which is automatically downloaded when testing (or by invoking a setup script directly).  Note: Testing is currently not supported for CMake-based builds.  ","version":"Next","tagName":"h2"},{"title":"Dependencies​","type":1,"pageTitle":"Installation","url":"/docs/getting_started/installation/#dependencies-1","content":" Some ReDex tests require a Java environment and Android compiler tooling. If a JDK and the Android SDK are available on the machine, ensure that javac and dx are available on the PATH. Otherwise, install those dependencies.  For Ubuntu/Debian, this may for example be done with  sudo apt-get install -y --no-install-recommends dalvik-exchange openjdk-8-jdk-headless sudo ln -s /usr/bin/dalvik-exchange /usr/local/bin/dx   ","version":"Next","tagName":"h3"},{"title":"Execute​","type":1,"pageTitle":"Installation","url":"/docs/getting_started/installation/#execute","content":" Run tests with  make -j check   If your build machine has lots of RAM (on the order of 2-4GB per core), using Make parallelism can speed up the build and testing (e.g., make -j4). However, the C++ compilers are very memory hungry and this needs to be finely tuned on many systems. ","version":"Next","tagName":"h3"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/docs/help/faq/","content":"","keywords":"","version":"Next"},{"title":"I'm getting \"Couldn't find zipalign. See README.md to resolve this.\" or other zipalign errors​","type":1,"pageTitle":"FAQ","url":"/docs/help/faq/#im-getting-couldnt-find-zipalign-see-readmemd-to-resolve-this-or-other-zipalign-errors","content":" zipalign is an optimization step that is bundled with the Android SDK. You need to tell redex where to find it. For example, if you installed the SDK at/path/to/android/sdk, try:  ANDROID_SDK=/path/to/android/sdk redex [... arguments ...]   You can alternatively add zipalign to your PATH, for example:  PATH=/path/to/android/sdk/build-tools/xx.y.zz:$PATH redex [... arguments ...]   Additionally, it's possible zipalign itself failed. In this case the stderr will be reported to aid debugging (for example, zipalign fails if you provide an output path that already exists).  ","version":"Next","tagName":"h2"},{"title":"My app fails to install with Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES]​","type":1,"pageTitle":"FAQ","url":"/docs/help/faq/#my-app-fails-to-install-with-failure-install_parse_failed_no_certificates","content":" After you run redex, you will need to re-sign your app. You can re-sign manually using these instructions:https://developer.android.com/tools/publishing/app-signing.html#signing-manually.  You can also tell redex to sign for you. If you want to sign with the debug key, you can simply do:  redex --sign [ ... arguments ...]   If you want to sign with your release key, you'll need to provide the appropriate args:  --sign Sign the apk after optimizing it -s [KEYSTORE], --keystore [KEYSTORE] -a [KEYALIAS], --keyalias [KEYALIAS] -p [KEYPASS], --keypass [KEYPASS]   ","version":"Next","tagName":"h2"},{"title":"My App crashes with MethodNotFoundException, ClassNotFoundException, NoSuchFieldException, or something similar. How do I fix this?​","type":1,"pageTitle":"FAQ","url":"/docs/help/faq/#my-app-crashes-with-methodnotfoundexception-classnotfoundexception-nosuchfieldexception-or-something-similar-how-do-i-fix-this","content":" Redex probably deleted or renamed it. Redex is quite aggressive about deleting things it deems are unreachable. But, often Redex doesn't know about reflection or other complex ways an entity could be reached.  Here's how you ensure Redex will not delete or rename something:  Annotate any class, method, or field you want to keep with @DoNotStrip, and add this to your ProGuard config file (which should be passed to redex.py via the --proguard-config flag):  # Do not strip classes annotated with @DoNotStrip -keep @com.path.to.your.DoNotStrip class * # Do not strip annotated fields or methods either -keepclassmembers class * { @com.path.to.your.DoNotStrip *; }   and define DoNotStrip:  package com.path.to.your; public @interface DoNotStrip {}   ","version":"Next","tagName":"h2"},{"title":"How does this compare to ProGuard?​","type":1,"pageTitle":"FAQ","url":"/docs/help/faq/#how-does-this-compare-to-proguard","content":" ReDex is conceptually similar to ProGuard, in that both optimize bytecode. ReDex, however, optimizes .dex bytecode, while ProGuard optimizes .class bytecode before it is lowered to .dex. Operating on .dex is sometimes an advantage: you can consider the number of virtual registers used by a method that is an inlining candidate, and you can control the layout of classes within a dex file. But ProGuard has some capabilities that ReDex does not (for example, ReDex will not remove unused method parameters, which ProGuard does).  ","version":"Next","tagName":"h2"},{"title":"How about DexGuard?​","type":1,"pageTitle":"FAQ","url":"/docs/help/faq/#how-about-dexguard","content":" DexGuard operates on dex, but we haven't evaluated it at all since it's closed source. We don't use it at Facebook and we have no plans to start. ","version":"Next","tagName":"h2"},{"title":"Usage","type":0,"sectionRef":"#","url":"/docs/getting_started/usage/","content":"","keywords":"","version":"Next"},{"title":"Basic Usage​","type":1,"pageTitle":"Usage","url":"/docs/getting_started/usage/#basic-usage","content":" To use ReDex, first build your app and find the APK for it. Then the simplest invocation is:  [python3] redex.py path/to/your.apk -o path/to/output.apk   A more complete invocation with:  the default configuration setting config/default.configaccess to the Android SDK tools  [python3] redex.py -c default.config \\ --android-sdk-path path/to/android/sdk \\ path/to/your.apk -o path/to/output.apk   The full set of options can be found with  [python3] redex.py --help   and at the time of writing is  usage: redex.py [-h] [-o [OUT]] [-j JARPATHS] [--redex-binary [REDEX_BINARY]] [-c CONFIG] [--sign] [-s [KEYSTORE]] [-a [KEYALIAS]] [-p [KEYPASS]] [-u] [--unpack-dest UNPACK_DEST] [-w [WARN]] [-d] [--dev] [-m [PROGUARD_MAP]] [--printseeds [PRINTSEEDS]] [--used-js-assets USED_JS_ASSETS] [-P PROGUARD_CONFIGS] [-k [KEEP]] [-A [ARCH]] [-S PASSTHRU] [-J PASSTHRU_JSON] [--lldb] [--gdb] [--ignore-zipalign] [--verify-none-mode] [--enable-instrument-pass] [--is-art-build] [--enable-pgi] [--post-lowering] [--disable-dex-hasher] [--page-align-libs] [--side-effect-summaries SIDE_EFFECT_SUMMARIES] [--escape-summaries ESCAPE_SUMMARIES] [--stop-pass STOP_PASS] [--output-ir OUTPUT_IR] [--debug-source-root [DEBUG_SOURCE_ROOT]] [--always-clean-up] [--cmd-prefix CMD_PREFIX] [--reset-zip-timestamps] [-q] [--android-sdk-path ANDROID_SDK_PATH] input_apk Given an APK, produce a better APK! positional arguments: input_apk Input APK file optional arguments: -h, --help show this help message and exit -o [OUT], --out [OUT] Output APK file name (defaults to redex-out.apk) -j JARPATHS, --jarpath JARPATHS Path to dependent library jar file --redex-binary [REDEX_BINARY] Path to redex binary -c CONFIG, --config CONFIG Configuration file --sign, --no-sign Sign the apk after optimizing it -s [KEYSTORE], --keystore [KEYSTORE] -a [KEYALIAS], --keyalias [KEYALIAS] -p [KEYPASS], --keypass [KEYPASS] -u, --unpack-only Unpack the apk and print the unpacked directories, don't run any redex passes or repack the apk --unpack-dest UNPACK_DEST Specify the base name of the destination directories; works with -u -w [WARN], --warn [WARN] Control verbosity of warnings -d, --debug Unpack the apk and print the redex command line to run --dev Optimize for development speed -m [PROGUARD_MAP], --proguard-map [PROGUARD_MAP] Path to proguard mapping.txt for deobfuscating names --printseeds [PRINTSEEDS] File to print seeds to --used-js-assets USED_JS_ASSETS A JSON file (or files) containing a list of resources used by JS -P PROGUARD_CONFIGS, --proguard-config PROGUARD_CONFIGS Path to proguard config -k [KEEP], --keep [KEEP] [deprecated] Path to file containing classes to keep -A [ARCH], --arch [ARCH] Architecture; one of arm/armv7/arm64/x86_64/x86&quot; -S PASSTHRU Arguments passed through to redex -J PASSTHRU_JSON JSON-formatted arguments passed through to redex --lldb Run redex binary in lldb --gdb Run redex binary in gdb --ignore-zipalign Ignore if zipalign is not found --verify-none-mode Enable verify-none mode on redex --enable-instrument-pass Enable InstrumentPass if any --is-art-build States that this is an art only build --enable-pgi If not passed, Profile Guided Inlining is disabled --post-lowering Specifies whether post lowering steps should be run --disable-dex-hasher Disable DexHasher --page-align-libs Preserve 4k page alignment for uncompressed libs --side-effect-summaries SIDE_EFFECT_SUMMARIES Side effect information for external methods --escape-summaries ESCAPE_SUMMARIES Escape information for external methods --stop-pass STOP_PASS Stop before a pass and dump intermediate dex and IR meta data to a directory --output-ir OUTPUT_IR Stop before stop_pass and dump intermediate dex and IR meta data to output_ir folder --debug-source-root [DEBUG_SOURCE_ROOT] Root directory that all references to source files in debug information is given relative to. --always-clean-up Clean up temporaries even under failure --cmd-prefix CMD_PREFIX Prefix redex-all with --reset-zip-timestamps Reset zip timestamps for deterministic output -q, --quiet Do not be verbose, and override TRACE. --android-sdk-path ANDROID_SDK_PATH Path to Android SDK   From here, you may want to read the configuration guide and details about the passes.  The result output.apk should be smaller and faster than the input.  ","version":"Next","tagName":"h2"},{"title":"Tracing​","type":1,"pageTitle":"Usage","url":"/docs/getting_started/usage/#tracing","content":" If you want some statistics about each pass, you can turn on tracing:  export TRACE=1   More specifically, tracing has categoriesand levels. For a TRACE(X, Y, msg) statement in the code to be logged, category X must have level Y or higher:  export TRACE=X:1,Y:2,Z:3   The output of tracing can also be redirected to a file with the TRACEFILEvariable:  export TRACEFILE=/path/to/trace.txt  ","version":"Next","tagName":"h2"},{"title":"Docker Container Deployments","type":0,"sectionRef":"#","url":"/docs/technical_details/docker/","content":"","keywords":"","version":"Next"},{"title":"Dockerfiles and DockerHub Images​","type":1,"pageTitle":"Docker Container Deployments","url":"/docs/technical_details/docker/#dockerfiles-and-dockerhub-images","content":" This section lists Dockerfiles and DockerHub images that provide various deployments of Redex.  ","version":"Next","tagName":"h2"},{"title":"Contribution by Andrew Chen (@yongjhih)​","type":1,"pageTitle":"Docker Container Deployments","url":"/docs/technical_details/docker/#contribution-by-andrew-chen-yongjhih","content":" GitHub source: https://github.com/yongjhih/docker-redexDockerHub image: https://hub.docker.com/r/yongjhih/redex/  Usage:  $ docker build --rm -t redex . $ docker run -it -v $ANDROID_SDK:/opt/android-sdk-linux -v $(pwd):/redex redex redex path/to/your.apk -o path/to/output.apk  ","version":"Next","tagName":"h3"},{"title":"Generating input data","type":0,"sectionRef":"#","url":"/docs/technical_details/interdex/","content":"","keywords":"","version":"Next"},{"title":"Step-by-Step on how to generate class list​","type":1,"pageTitle":"Generating input data","url":"/docs/technical_details/interdex/#step-by-step-on-how-to-generate-class-list","content":" Connect your device to your computer, so you can execute adb commands. You need to have root on your device to execute the dump heap command. On your computer:  // get the process if of your app  adb shell ps | grep YOUR_APP_NAME | awk '{print $2}' &gt; YOUR_PID ( if you don't have awk, the second value is the pid of your app)   // dump the heap of your app. You WILL NEED ROOT for this step  adb root adb shell am dumpheap YOUR_PID /data/local/tmp/SOMEDUMP.hprof   // copy the heap to your host computer  adb pull /data/local/tmp/SOMEDUMP.hprof YOUR_DIR_HERE/.   // pass the heap dump to the python script for parsing and printing out the class list // Note that the script needs python 3  redex/tools/hprof/dump_classes_from_hprof.py --hprof YOUR_DIR_HERE/SOMEDUMP.hprof &gt; list_of_classes.txt   If everything worked out, list_of_classes.txt will contain a large number of lines of the form foobar.class You'll note that many of the classes list are actually classes provided by the system and not from your app. This is ok, since the Interdex Pass will ignore any entries for which it cannot find the corresponding classes to in the apk.  Note: you must have enum34 installed for the script to work.  Usage  To enable the Interdex pass for you application, add the following to your config file:  add &quot;InterDexPass&quot; to passesadd &quot;coldstart_classes&quot;: &quot;list_of_classes.txt&quot; to the config file  ","version":"Next","tagName":"h2"},{"title":"Options​","type":1,"pageTitle":"Generating input data","url":"/docs/technical_details/interdex/#options","content":" There are two flags that can be set to influence the behavior of the Interdex pass  emit_canaries: This flag controls whether each secondary dex has a non-functional canary class added. Defaults to false. Enable this only if you explicitly know that you need it. static_prune: This flag controls whether Interdex attempts to remove classes that have no references to them from the rest of the set of classes in the pgo list.  Measuring benefit  Install an apk without interdex pass enabled adb shell ps | grep YOUR_APP_NAME | awk '{ print $2 }' &gt; YOUR_PID adb shell dumpsys meminfo YOUR_PID Note how much memory your app uses and the .dex mmap rowDo all the steps described above and rerun redex with the Interdex Pass enabled and using the profiling data you generatedInstall the apk with interdex enabledstart the app and repeat the step to get the meminfoNote total memory usage and .dex mmap in particularHopefully memory usage has gone down!  If you want performance measurements, you'll have to set up a test for app startup and run it on apks with and without the interdex pass applied. ","version":"Next","tagName":"h2"},{"title":"Passes","type":0,"sectionRef":"#","url":"/docs/getting_started/passes/","content":"","keywords":"","version":"Next"},{"title":"AccessMarkingPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#accessmarkingpass","content":" Final objects and private methods can be optimized more aggressively than virtual objects and public methods.  Devirtualization can result in [NullPointerException]. Two Redex passes perform devirtualization of methods: AccessMarkingPass devirtualizes methods not usingthis. MethodInlinePass inlines monomorphic virtual calls.  The app's config file can override AccessMarkingPass behavior.finalize_methods, finalize_unwritten_fields, finalize_classes, andprivatize_methods default to true. finalize_written_fields defaults to false.  &quot;AccessMarkingPass&quot;: { &quot;finalize_written_fields&quot;: true },   Pass ordering dependencies:  AccessMarkingPass should be run early as it enables other optimizations.  See related:  MethodDevirtualizationPass  ","version":"Next","tagName":"h2"},{"title":"AnnoKillPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#annokillpass","content":" AnnoKillPass originally removed only annotations with no static references in the code--&quot;build-visible&quot; annotations. It was expanded to remove annotations referenced statically, but not used at runtime--&quot;runtime-visible&quot; annotations.  AnnoKillPass reads configuration options from the app's config file specifying annotations to be kept or killed. An additional option specifies whether Redex should attempt to match signatures for removal.  &quot;AnnoKillPass&quot; : { &quot;keep_annos&quot;: [ &quot;Landroid/view/ViewDebug$CapturedViewProperty;&quot;, &quot;Landroid/view/ViewDebug$ExportedProperty;&quot; ], &quot;kill_bad_signatures&quot; : true, &quot;kill_annos&quot; : [ &quot;Lcom/google/inject/BindingAnnotation;&quot; ] },   See related:  SystemAnnoKillPass  ","version":"Next","tagName":"h2"},{"title":"BridgeSynthInlinePass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#bridgesynthinlinepass","content":" As the name suggests BridgeSynthInlinePass removes bridge and synthetic methods by inlining them.  Bridge methods are created by the javac compiler as part of type erasure for covariant generics.  Example of a bridge method in pseudo-bytecode:  check-cast* (for checking covariant arg types) invoke-{direct,virtual,static} bridged-method move-result return   BridgeSynthInlinePass inlines the target of the bridging, the &quot;bridgee&quot;, into the bridge method by replacing the invoke- and adjusting check-casts as needed. The bridgee can then be deleted.  BridgeSynthInlinePass also removes synthetic methods introduced by javac. javac generates these methods because while Java allows inner classes or nested classes, DEX bytecode does not. Inner classes, like class Delta in this example, are promoted to top-level classes in the DEX bytecode.  public class Gamma { public Gamma(int v) { x = v; } private int x; public class Delta { public int doublex() { return 2*x; } } }   javac generates a synthetic method that allows access to fields, methods, and constructors in the promoted class. SynthPass effectively removes these synthetic methods, replacing them with a direct access to the field or call to the method or constructor.  The general limitations and the cost model of the inliner applies. As a result, some bridge and synthetic method inlining opportunities might not be acted upon, e.g. when it would result in API-level violations, or an overall size increase.  ","version":"Next","tagName":"h2"},{"title":"CheckBreadcrumbsPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#checkbreadcrumbspass","content":" CheckBreadcrumbsPass validates Redex codegen against leftover references to deleted types, methods, or fields.  Verifies that there are no references to a deleted class definition remaining in DEX files (essentially an internal class that is not in scope).Verifies that the target of a field and method reference exists on the class it is defined on.  Redex will warn if it finds dangling references or illegal references to entities.  ","version":"Next","tagName":"h2"},{"title":"ClassMergingPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#classmergingpass","content":" ClassMergingPass shrinks the size of code generated by some frameworks. These tools produce large amounts of Java code for each component. The code generated for different component types often shares the same structure, differing only by the type of the component.  Class Merging identifies pieces of generated code that have the same &quot;shape&quot;. Erasing the types that differ allows the pieces of generated code to be merged.  ","version":"Next","tagName":"h2"},{"title":"ConstantPropagationPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#constantpropagationpass","content":" ConstantPropagationPass substitutes the values of constants into expressions at compile time. Constant propagation can eliminate multiple expressions, resulting in a constant load.  ConstantPropagationPass does a whole program analysis to replace instructions with single destination registers with constant loads. The analysis is run iteratively until a fixed point or configurable limit is reached.  CostantPropagationPass should be run before dead code elimination (DCE) passes as it can create dead code.  See related:  LocalDCEPassRemoveUnreachablePass  ","version":"Next","tagName":"h2"},{"title":"CopyPropagationPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#copypropagationpass","content":" CopyPropagationPass removes writes of duplicated values to registers in a basic block. If value A and value B are aliases, then any moves between these registers are unnecessary and can be eliminated. Duplicated source registers can also be deduplicated.  CopyPropagationPass can also remove duplicated instructions if the source and the destination are aliased.  Example: v0 and v1 contain the same value and can be treated locally as aliases:  const v0, 0 const v1, 0 invoke-static v0 foo invoke-static v1 bar   can be transformed into  const v0, 0 invoke-static v0 foo invoke-static v0 bar   CopyPropagationPass should be run before dead code elimination (DCE) passes as it can create dead code.  See related:  LocalDCEPassRemoveUnreachablePass  ","version":"Next","tagName":"h2"},{"title":"DedupBlocksPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#dedupblockspass","content":" Dedup blocks inside of a method. Duplicated blocks are those with the same code and the same successor. Duplicated blocks can have different predecessors.  DedupBlocksPass identifies one of the blocks as the canonical version, then redirects all predecessors to the canonical block. The pass currenly only identifies blocks with a single successor, but in the future may identify blocks with multiple sucessors.  Stack traces for deduplicated blocks will always report the same line number, but the predecessor line numbers will be correct.  DedupBlocksPass should be run after InterDexPass.  ","version":"Next","tagName":"h2"},{"title":"DelSuperPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#delsuperpass","content":" DelSuperPass eliminates subclass methods that invoke the superclass method and trivially return.  DelSuperPass only optimizes virtual methods with the following characteristics:  The subclass method must match the name and signature of the superclass methodThe subclass method must only invoke the superclass method and either returnvoid or the result of the callee.  DelSuperPass also fixes up references to the removed subclass methods, making them refer to the superclass method instead. Though Dalvik'sinvoke-virtualwould automatically resolve to the correct superclass method, doing this reduces the number of method references in the Dex file and saves on space.  ","version":"Next","tagName":"h2"},{"title":"FinalInlinePassV2​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#finalinlinepassv2","content":" FinalInlinePassV2, or an instance field's value after &lt;init&gt;, and inlines the value in dex code. Note that this pass is separate from the MethodInlineand SwitchInline passes.  The DX tool often introduces verbose bytecode sequences to initialize static fields in classes it generates. The encoded_value equivalents are much more compact. This pass determines the values of static fields after &lt;clinit&gt; and eliminates the redundant writes to the static field.  This pass applies to both final and non-final static fields. For final statics it also inlines reads of the static field where possible, replacing them with constant operations outside of &lt;clinit&gt;.  For instance fields, the pass calculates the field's value after &lt;init&gt; is finished. It inlines reads of the instance field where possible.  Unlike a static field, if an instance field were changed outside of &lt;init&gt;, it might have different values for different instances of the class. For classes with multiple &lt;init&gt; the instance field values might differ based on the constructor. This pass does not inline instance fields that are:  Modified outside of their class &lt;init&gt;.In a class that have more than one constructor.Accessed by reflection or native code anywhere in code.Accessed in another method that is called inside of the constructor.  Note that this pass does not inline the CharSequence type for static or instance fields because older Dalvik VMs cannot handle this class.  See related:  MethodInlinePass  ","version":"Next","tagName":"h2"},{"title":"LocalDcePass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#localdcepass","content":" LocalDcePass removes dead instructions in a method. Code is considered to be &quot;dead' if it has no side-effects and does not change its output registers. Code in a catch block is considered live for the duration of the try, as any instruction in the try block is assumed to be able to throw. Methods annotated with @DoNotOptimize are not considered for dead code elimination.  Dead code elimination (DCE) differs from RemoveUnreachable (RMU) in two ways: first, RMU works from global roots (at the scope of Class/Method/Field) whereas DCE works at the function scope. Second, DCE removes code that does not change state, for example, a store to a memory address that is not read in the scope of the block, whereas RMU removes code that is unreachable regardless of its effect on state.  See related:  RemoveUnreachablePass  ","version":"Next","tagName":"h2"},{"title":"MethodDevirtualizationPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#methoddevirtualizationpass","content":" MethodDevirtualizationPass converts virtual methods with single implementation to static dmethods.  The app's config file:  &quot;MethodDevirtualizationPass&quot; : { &quot;staticize_vmethods_not_using_this&quot; : true, &quot;staticize_dmethods_not_using_this&quot; : true },   See related:  AccessMarkingPass  ","version":"Next","tagName":"h2"},{"title":"ObfuscatePass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#obfuscatepass","content":" ObfuscatePass pass obfuscates method and field names. RenameClassesPassV2obfuscates class names.  See related:  RenameClassesPassV2  ","version":"Next","tagName":"h2"},{"title":"OptimizeEnumsPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#optimizeenumspass","content":" OptimizeEnumsPass does two things to make use of Enum classes more efficient. It optimizes the use of Enum values in switch tables and replaces some uses of Enum values with Integer singletons.  The javac compiler creates Dalvik packed switch tables that contain a generated anonymous class. OptimizeEnumPass replaces these packed switch statements with lookups based on the Enum ordinal itself. Note that this optimization does not work with ProGuard obfuscation enabled. ProGuard can rewrite Enum value names such that they no longer match the Enum class name.  OptimizeEnumsPass also replaces some uses of an Enum with a boxed Integersingleton and keeps the runtime behavior unchanged at the same time.  The pass does not guarantee to erase all the enums, perf sensitive code should never use enums. An Enum is not optimizable if it is:  An abstract Enum.Reflectively used.Contains an instance field that is not a primitive.Contains non-final instance fields.Cast to any other types, like java.lang.Object, java.lang.Enum,java.io.Serializable, java.lang.Comparable  ","version":"Next","tagName":"h2"},{"title":"OriginalNamePass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#originalnamepass","content":" &quot;OriginalNamePass&quot; : { &quot;hierarchy_roots&quot; : [ &quot;Ljava/lang/Runnable;&quot; ] },   Redex renames classes for performance reasons. Renaming can result in different class names in debug and release builds, which results in mismatches in logging. Also, some system functions should not be renamed.  An alternative is to use OriginalClassName.getSimpleName() for logging.OriginalNamePass is preferred as is does not significantly increase the APK size.  ","version":"Next","tagName":"h2"},{"title":"PeepholePass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#peepholepass","content":" Replace small code patterns with a more efficient pattern. The optimization matches known patterns for replacement. It essentially performs a string search of the code for known inefficient sequences and replaces them with more efficient code. PeepholePass will not replace patterns that span a basic block boundary. PeepholePass can remove no-op function calls such as redundant moves and appends of null strings.  Peephole pass should be run early.  ","version":"Next","tagName":"h2"},{"title":"ReBindRefsPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#rebindrefspass","content":" Rebind references to their most abstract type.  The number of methods in a DEX file is limited to 64K. Method definitions (defs) and references (refs) both count against this limit. The class scope in an inheritance situation can create needless method refs. Calls based on the subclassed methods create unnecessary method refs for the subclass. This is especially true when calls are made through the implicit this.  For example, you have a class specialized on &lt;n&gt; with a method that callsObject.equals(Object). All of these calls create a ref X&lt;n&gt;.equals(Object), each of them counting against the 64K limit. Rebinding them lower in the hierarchy reduces the number of unique refs.  class X&lt;n&gt; { public void foo&lt;n&gt;(Object o) { ... if (equals(o) {...} ... } }   ReBindRefsPass rebinds all invoke-virtual to the base def of the virtual scope. For invoke-interface, it rebinds to the first interface method def. The optimization is only done as long as there is no change in method visibility: we walk down the hiearchy as long as the method is public. ReBindRefsPassdrastically reduces the number of methods defined in DEX files.  ","version":"Next","tagName":"h2"},{"title":"ReduceGotosPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#reducegotospass","content":" Reduces gotos in two ways:  When a conditional branch would fallthrough to a block that has multiple sources, and the branch target only one has one, invert condition and swap branch and goto target. This reduces the need for additional gotos and maximizes the fallthrough efficiency.It replaces gotos that eventually simply return by return instructions. Return instructions tend to have a smaller encoding than goto instructions, and tend to compress better due to less entropy (no offset).  Example, inverting this conditional will eliminate a goto:  (const v2 0) (if-eqz v0 :true) (:back_jump_target) (return v2) (:true) (const v2 1) (goto :back_jump_target)   ","version":"Next","tagName":"h2"},{"title":"RegAllocPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#regallocpass","content":" RegAllocPass does register allocation: the process of allocating variables into the available physical registers. The goal of register allocation is to avoid &quot;spilling&quot;, that is, moving values from registers into memory.  RegAllocPass uses a standard graph-coloring register allocator algorithm, known as the Chaitin-Briggs algorithm.  ","version":"Next","tagName":"h2"},{"title":"RemoveBuildersPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#removebuilderspass","content":" Remove builder invocations. A trivial builder is one that:  Doesn't escape the stack (this is never passed to a method not in this instance, stored in a field, or returned)Has no static methodsHas no static fields  Unreferenced builders are left to be removed by RemoveUnreachablePass (RMU).  See related:  RemoveUnreachablePassResultPropagationPass  ","version":"Next","tagName":"h2"},{"title":"RemoveInterfacePass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#removeinterfacepass","content":" The motivation of this pass is to remove a hierarchy of interfaces extending each others. The removal of the interfaces simplifies the type system and enables additional type system level optimizations.  We remove each interface by replacing each invoke-interface site with a generated dispatch stub that models the interface call semantic at bytecode level. After that we remove the existing references to them from the implementors and remove them completely. We start at the leaf level of the interface hierarchy. After removing the leaf level, we iteratively apply the same transformation to the now newly formed leaf level again and again until all interfaces are removed.  Note that this is a critical pass for optimizing GraphQL generated fragment models. Aside from the fragment model classes themselves, the GraphQL tool chain also generates a Java interface for each GraphQL fragment namely fragment interface. The existence of these interfaces greatly complicates the type system of the generated GraphQL fragment models making merging the underlying model classes virtually impossible. The other interface removal optimizations likeSingleImpl as well as RemoveUnreachablePass can address this issue to some extend. But they are not able to remove the majority of them.RemoveInterfacePass is capable of removing most of the fragment interfaces at the expense of producing the above mentioned dispatch stubs. Doing so before Class Merging paves the way for maximizing the code size reduction we can achieve in Class Merging.  ","version":"Next","tagName":"h2"},{"title":"RemoveUnreachablePass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#removeunreachablepass","content":" Starting from the roots, recursively mark the other elements that the roots reference. Afterwards, it deletes all the unmarked elements.  The pass has various powerful options, including:  remove_no_argument_constructors: Whether to remove argless constructors. They might be used to create instances via reflection, so the default is false.relaxed_keep_class_members: Only consider instance members as roots when their classes are either instantiable, i.e. have a callable constructor, or are &quot;dynamically referenced&quot;. A class is &quot;dynamically referenced&quot; if it is mentioned in a Dalvik annotation signature, is referenced in a runtime-visibile annotation, appears in a string or a const-class instruction, is the declaring type of a native method, is present in a native library (lib//.so), has one of the configured &quot;reflected_package_names&quot;. The default is false for backwards compatibility.throw_propagation: When reachable instructions invoke methods that cannot return (e.g. all possible target methods have no reachable return statement), then subsequent instructions will not be visited, and replaced with a unreachable instruction. The default is false for backwards compatibility.prune_uninstantiable_insns: When reachable instructions access instance members of classes that can never be instantiated, then subsequent instructions will not be visited, and replaced with an instruction that throws a NullPointerException. The default is false for backwards compatibility.prune_uncallable_instance_method_bodies: When an instance method can never be target of an invocation, even though we might need to keep the method for virtual scope order, or because of keep rules, then we can replace its body with an unreachable instruction. This draws from the same instantiability knowledge that is used for the prune_uninstantiable_insns option. The default is false for backwards compatibility.prune_uncallable_virtual_methods: In some cases, we don't need to keep the body of an uncallable method, but instead can make the method abstract, or remove it completely. The default is false for backwards compatibility.prune_unreferenced_interfaces: Removes interfaces that are not referenced anywhere in code except in implements clauses. The default is false for backwards compatibility.  More information about RemoveUnreachablePass is available in this [note on Teaching Reachability Analysis about Dependency Injection].  See related:  LocalDcePass  ","version":"Next","tagName":"h2"},{"title":"RemoveUnusedFieldsPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#removeunusedfieldspass","content":" It's pretty much in the name. A lot of these unread fields are actuallyjavac-generated fields for inner classes. Notably, this turns non-static inner classes into static ones where possible.  This pass occasionally causes issues because the app may have been relying on an unread field to stop the GC from deleting an object.  ","version":"Next","tagName":"h2"},{"title":"RemoveUnusedArgsPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#removeunusedargspass","content":" Removes unused parameters. Currently only works on non-virtual methods and virtual methods that are not part of some overriding inheritance hierarchy.  ","version":"Next","tagName":"h2"},{"title":"RenameClassesPassV2​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#renameclassespassv2","content":" RenameClassesPassV2 renames classes to shorter names such as &quot;X.A1c&quot;, saving in APK size, obfuscating the code, and ordering classes to optimize performance of loading.  RenameClassesPassV2 will not rename any class mentioned in resources, nor will it rename anything in blocklist either by direct class name or as part of an excluded package.  RenameClassesPassV2 relies on the app's config file, excluding of the class or hierarchy, or use of reflection.  Logview and bug reports are configured to automatically undo this renaming.  See related:  ObfuscatePass  ","version":"Next","tagName":"h2"},{"title":"ReorderInterfacesDeclPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#reorderinterfacesdeclpass","content":" ReorderInterfacesDeclPass list for each class by how frquently the Interfaces are called. The Interface list is searched linearly when an Interface is called, so calling an Interface at the list will be faster. An alphabetical sort is used for tie-breaks in number of incoming calls to preserve consistency across Classes.  This pass could be improved by checking the number of incoming calls dynamically.  ","version":"Next","tagName":"h2"},{"title":"ResultPropagationPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#resultpropagationpass","content":" Refactor code, e.g.,  Text.create(context) .clipToBounds(false) .text(myText)   to be as efficient as the less elegant equivalent version:  Text.Builder b = Text.create(context); b.clipToBounds(false) b.text(myText)   See related:  RemoveBuildersPass  ","version":"Next","tagName":"h2"},{"title":"ShortenSrcStringsPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#shortensrcstringspass","content":" Replaces long filename strings with strings used elsewhere in the APK. This munges the filename component of stack traces. Logview and bug reports automatically reverse this for you.  ","version":"Next","tagName":"h2"},{"title":"MethodInlinePass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#methodinlinepass","content":" For example, in this code, if run is inlined to main and the access of barthrows, the stack trace in main will show a NullPointerException at the dereference of this instead of a call to run.  class Foo { private String bar; public void run() { System.out.println(bar); } } class Main { public static void main(String[] args) { Foo foo = null; foo.run(); } }   MethodInlinePass will not inline a constructor as the Android verifier checks for a call to &lt;init&gt; before any access to the object.  MethodInlinePass cannot currently be run after InterDexPass.  See related:  FinalInlinePassV2  ","version":"Next","tagName":"h2"},{"title":"SingleImplPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#singleimplpass","content":" Removes interfaces with only a single implementation. Any classes referring to the interface will now refer to the implementation instead. This can cause minor confusion in stack traces.  ","version":"Next","tagName":"h2"},{"title":"StaticReloPassV2​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#staticrelopassv2","content":" StaticReloPassV2 relocates static fields and methods that only have one calling class to that class. It improves the performance and reduces the app size.  See related:  StaticReloPass  ","version":"Next","tagName":"h2"},{"title":"StringConcatenatorPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#stringconcatenatorpass","content":" Reduce string operations as well as reducing the number of strings that need to be loaded.  Here's an example &lt;clinit&gt; method StringConcatenationPass will optimize:  public static final String PREFIX = &quot;foo&quot;; public static final String CONCATENATED = PREFIX + &quot;bar&quot;;   The output code should be equivalent to:  public static final PREFIX = &quot;foo&quot;; public static final CONCATENATED = &quot;foobar&quot;;   This is a targeted optimization that is only performed on static initializers with many string concatenations.  ","version":"Next","tagName":"h2"},{"title":"StripDebugInfoPass​","type":1,"pageTitle":"Passes","url":"/docs/getting_started/passes/#stripdebuginfopass","content":" StripDebugInfoPass removes debug information for instructions that will never throw. As debug positions can correspond to multiple instructions, we need to check that none of the instructions will throw. Also, Redex won't strip the first piece of debug information in a function to preserve the accuracty of sampling profiles and ANR stack traces.  The app's config file can direct StripDebugInfoPass removals at a more granular level:  &quot;StripDebugInfoPass&quot; : { &quot;drop_all_dbg_info&quot; : &quot;0&quot;, &quot;drop_local_variables&quot; : &quot;1&quot;, &quot;drop_line_numbers&quot; : &quot;0&quot;, &quot;drop_src_files&quot; : &quot;0&quot;, &quot;use_allowlist&quot; : &quot;0&quot;, &quot;cls_allowlist&quot; : [], &quot;method_allowlist&quot; : [], &quot;drop_prologue_end&quot; : &quot;1&quot;, &quot;drop_epilogue_begin&quot; : &quot;1&quot;, &quot;drop_all_dbg_info_if_empty&quot; : &quot;1&quot;, &quot;drop_synth_aggressive&quot; : &quot;0&quot;, &quot;drop_line_numbers_preceeding_safe&quot; : &quot;1&quot; },   Pass ordering dependencies:  StripDebugInfoPass should be run early as removal of the debug info should make other passes faster.Inlining complicates the flow graph for debug info. StripDebugInfoPassshould be run before any inlining passes, and will not optiimize if inlining has been performed. ","version":"Next","tagName":"h2"}]